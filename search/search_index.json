{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"DIDComm V2 Guidebook If you're a developer who wants to learn the practicalities of DIDComm -- getting started, common recipes, libraries and tools, the theory behind the spec , or how your peers are solving interesting problems -- this is the place. This is a living doc, updated and expanded regularly by the DIDComm User Group . If you have suggestions for the book, we welcome your contributions ; reach out to us on Discord or email for help. This version of the book focuses on DIDComm v2 (the one incubated by DIF, finalized in early 2022). For info about migration from DIDComm v1 , see Appendix: Migration from DIDComm v1 . A new version of DIDComm, v3, is imagined. This would be an IETF standard that builds on v2 with a session construct, improved binary support, leaner messages for IoT, and so forth. When we have links for that work, we'll add them here. Contents Why DIDComm? Latest DIDComm community activity Hello World Choosing libraries and tools Putting a message in an encrypted envelope Hello World in Python Starting, using and ending a DIDComm connection Threading Protocols Implementing a protocol Designing your own protocol When this makes sense Conventions Best practices Sharing your protocol Co-protocols Recipes Debugging Timeouts Retries Localization N-wise Bootstrapping Using DIDComm security outside DIDComm Dealing with mobile agents Problem Codes Safety Privacy Security Authcrypt vs. Anoncrypt Choosing curves Choosing DID methods Message security contexts DID rotation Perfect forward secrecy Man in the middle Routing Extensions Frequently Asked Questions OpenID4VC Appendix: Migration from DIDComm v1 What's new Migrator script","title":"Home"},{"location":"#didcomm-v2-guidebook","text":"If you're a developer who wants to learn the practicalities of DIDComm -- getting started, common recipes, libraries and tools, the theory behind the spec , or how your peers are solving interesting problems -- this is the place. This is a living doc, updated and expanded regularly by the DIDComm User Group . If you have suggestions for the book, we welcome your contributions ; reach out to us on Discord or email for help. This version of the book focuses on DIDComm v2 (the one incubated by DIF, finalized in early 2022). For info about migration from DIDComm v1 , see Appendix: Migration from DIDComm v1 . A new version of DIDComm, v3, is imagined. This would be an IETF standard that builds on v2 with a session construct, improved binary support, leaner messages for IoT, and so forth. When we have links for that work, we'll add them here.","title":"DIDComm V2 Guidebook"},{"location":"#contents","text":"Why DIDComm? Latest DIDComm community activity Hello World Choosing libraries and tools Putting a message in an encrypted envelope Hello World in Python Starting, using and ending a DIDComm connection Threading Protocols Implementing a protocol Designing your own protocol When this makes sense Conventions Best practices Sharing your protocol Co-protocols Recipes Debugging Timeouts Retries Localization N-wise Bootstrapping Using DIDComm security outside DIDComm Dealing with mobile agents Problem Codes Safety Privacy Security Authcrypt vs. Anoncrypt Choosing curves Choosing DID methods Message security contexts DID rotation Perfect forward secrecy Man in the middle Routing Extensions Frequently Asked Questions OpenID4VC Appendix: Migration from DIDComm v1 What's new Migrator script","title":"Contents"},{"location":"authentication/","text":"Message Authentication TODO: Add details about authenticated encryption.","title":"Authentication"},{"location":"authentication/#message-authentication","text":"TODO: Add details about authenticated encryption.","title":"Message Authentication"},{"location":"didcomm_verticals/","text":"DIDComm applied to Technology Verticals DIDComm can be used for many things. Some of these applications can be grouped into technology verticals, described below and detailed on related pages. Verifiable Credentials DIDComm provides an excellent way to coordinate Verifible Credential activities between parties. Human Communication Enables human-oriented communication between parties leveraging the security and privacy of DIDComm. Often used in a supporting role alongside other protocols. Additional Protocol Development DIDComm supports the development of additional protocols in any technology vertical. Creating a new protocol and promoting it can add useful funcationality into the ecosystem. Support for these protocols can be detected with the Discover Features protocol when communicating with other software.","title":"Applications"},{"location":"didcomm_verticals/#didcomm-applied-to-technology-verticals","text":"DIDComm can be used for many things. Some of these applications can be grouped into technology verticals, described below and detailed on related pages.","title":"DIDComm applied to Technology Verticals"},{"location":"didcomm_verticals/#verifiable-credentials","text":"DIDComm provides an excellent way to coordinate Verifible Credential activities between parties.","title":"Verifiable Credentials"},{"location":"didcomm_verticals/#human-communication","text":"Enables human-oriented communication between parties leveraging the security and privacy of DIDComm. Often used in a supporting role alongside other protocols.","title":"Human Communication"},{"location":"didcomm_verticals/#additional-protocol-development","text":"DIDComm supports the development of additional protocols in any technology vertical. Creating a new protocol and promoting it can add useful funcationality into the ecosystem. Support for these protocols can be detected with the Discover Features protocol when communicating with other software.","title":"Additional Protocol Development"},{"location":"didrotation/","text":"DID Rotation DIDComm Messaging relies on the DIDs , and associated DID Documents , of the two peers involved in the communication. Those parties are responsible to secure their keys by performing rutinely key rotations, even if they are not compromised, and to make other changes in the DID Documents as needed, such as service endpoints. DIDComm has no involvement in that procedure that is particular to each DID method; nevertheless and provided that the DID does not change, the communication can keep flowing normally. However there are cases when the DID (not the DID Document) need to be rotated by one of the parties, such as in the following three cases: 1. At the beginning of a connection: its common that the initial message is in the form of an Out of Band message that it is unencrypted per definition, and may be observed by another party or transmitted in an unsecure channel such as a QR code or a URL posted in an email or webpage. The DID used in the OOB should be considered as a temporal DID just to start the conversation, but it is highly recommended that it is rotated afterwards to improve privacy. 2. When keys inside a DID Document need to be rotated and the DID method does not allow updating the DID Document with new rotated keys, as is the case for did:key . 3. If there is a need to move to a different DID method for whatever reason (security, flexibility, interoperability, etc) DIDComm defines a specific header to handle DID rotation. This header is called from_prior and can be used in any message sent to the other party. That message must include the from_prior header that is a standard JWT token conformed with: - Header: - typ : jwt - alg : verification algorithm such as EdDSA - crv : curve name - kid : key id from previous DID that is used in the signature of this JWT - Payload: - sub : the new DID - iss : the previous DID - iat : datetime in seconds - Signature: from the previous DID and key defined in the kid Once a DIDComm agent receives a message from an unknown DID, it must: 1. check if there\u2019s a from_prior header 2. if exists, extract the DID from the iss and validate if it matches a known DID 3. validate JWT signatures using the key defined in kid and extracted from previous DID defined in iss 4. if all validations are successful, the new DID should be stored for future communications with the previously known agent The sender, who's doing the rotation, should continue to send the rotation header until they receive a message from the other party using the new DID. This allows for continuity even if one party is offline or not processing messages for a while. Example code showing a DID Rotation after an Out of Band message can be found in the section Starting, using and ending a DIDComm connection from this Guidebook. Since DIDComm is asynchronous in nature, messages can arrive in different order. Sender and receiver should take care to: - Sender: avoid starting a DID rotation in the middle of multiple message conversations. If DID rotation arrives out of order, some messages may be discarded by the recipient. - Receiver: messages received from the old DID but after the message that performs the DID rotation must be discarded to reduce the risk of potentially compromised keys. Finally, DID rotation allows a special case when rotating to nothing that denotes the end of the relationship . In this case the DID should be omitted from the from header and from the sub field of the from_prior header.","title":"Didrotation"},{"location":"didrotation/#did-rotation","text":"DIDComm Messaging relies on the DIDs , and associated DID Documents , of the two peers involved in the communication. Those parties are responsible to secure their keys by performing rutinely key rotations, even if they are not compromised, and to make other changes in the DID Documents as needed, such as service endpoints. DIDComm has no involvement in that procedure that is particular to each DID method; nevertheless and provided that the DID does not change, the communication can keep flowing normally. However there are cases when the DID (not the DID Document) need to be rotated by one of the parties, such as in the following three cases: 1. At the beginning of a connection: its common that the initial message is in the form of an Out of Band message that it is unencrypted per definition, and may be observed by another party or transmitted in an unsecure channel such as a QR code or a URL posted in an email or webpage. The DID used in the OOB should be considered as a temporal DID just to start the conversation, but it is highly recommended that it is rotated afterwards to improve privacy. 2. When keys inside a DID Document need to be rotated and the DID method does not allow updating the DID Document with new rotated keys, as is the case for did:key . 3. If there is a need to move to a different DID method for whatever reason (security, flexibility, interoperability, etc) DIDComm defines a specific header to handle DID rotation. This header is called from_prior and can be used in any message sent to the other party. That message must include the from_prior header that is a standard JWT token conformed with: - Header: - typ : jwt - alg : verification algorithm such as EdDSA - crv : curve name - kid : key id from previous DID that is used in the signature of this JWT - Payload: - sub : the new DID - iss : the previous DID - iat : datetime in seconds - Signature: from the previous DID and key defined in the kid Once a DIDComm agent receives a message from an unknown DID, it must: 1. check if there\u2019s a from_prior header 2. if exists, extract the DID from the iss and validate if it matches a known DID 3. validate JWT signatures using the key defined in kid and extracted from previous DID defined in iss 4. if all validations are successful, the new DID should be stored for future communications with the previously known agent The sender, who's doing the rotation, should continue to send the rotation header until they receive a message from the other party using the new DID. This allows for continuity even if one party is offline or not processing messages for a while. Example code showing a DID Rotation after an Out of Band message can be found in the section Starting, using and ending a DIDComm connection from this Guidebook. Since DIDComm is asynchronous in nature, messages can arrive in different order. Sender and receiver should take care to: - Sender: avoid starting a DID rotation in the middle of multiple message conversations. If DID rotation arrives out of order, some messages may be discarded by the recipient. - Receiver: messages received from the old DID but after the message that performs the DID rotation must be discarded to reduce the risk of potentially compromised keys. Finally, DID rotation allows a special case when rotating to nothing that denotes the end of the relationship . In this case the DID should be omitted from the from header and from the sub field of the from_prior header.","title":"DID Rotation"},{"location":"extensions/","text":"Extensions Extension adds a self-contained set of conventions or features. Support for them is optional. The following is a list of available extensions. Note that we are in the process of formalizing the status of each extension specification, they should be treated as DRAFT for the moment: Advanced Sequencing Email Transport L10n Return-Route and Queue Transport","title":"Extensions"},{"location":"extensions/#extensions","text":"Extension adds a self-contained set of conventions or features. Support for them is optional. The following is a list of available extensions. Note that we are in the process of formalizing the status of each extension specification, they should be treated as DRAFT for the moment: Advanced Sequencing Email Transport L10n Return-Route and Queue Transport","title":"Extensions"},{"location":"faq/","text":"Intro This file will work as a lightweight frequently asked questions before it grows into something unmanagable and needs to have better structure on it. For now this will offer a simple content adressing list an link to each question. We have sections of questions and questions underneath each section. They link directly to each question. Cryptography How kosher is it to do non encrypted messages? How kosher is it to do non encrypted messages? Since it is an option to not encrypt DIDComm messages, and we want to be clear on how you can reason about it The answer to \"how kosher\" depends on two subquestions: Are you uninterested in confidentiality because the message is intended to be public anyway (e.g., it's a message inviting anyone in the general public to send you a message)? Will the message stay within trust domain boundaries? (That is, Alice sends an encrypted message to Bob; Bob decrypts and wants to send it as plaintext to 5 of his agents, but all of them are within his own sphere of control, and Bob trusts himself.) If the answer to either of these questions is \"Yes\", then we think non encrypted messages are completely fine. If the answer to both of these questions is \"No\", then we think messages should be encrypted, because it means confidentiality should matter. It might be tempting to say, \"True. But I'm using https, which gives confidentiality anyway.\" This is a fallacy, because by design a sender in DIDComm doesn't actually know the full route to the target. A sender might be using HTTPS, but perhaps part of the route is not. Using channel-oriented encryption (e.g., TLS) on the part of the channel you can see is not actually secure, if someone somewhere has to take plaintext off that channel and put it somewhere else that you don't know about. The guarantee is supposed to be end-to-end. (In our question #2 above, \"Bob\" is the end; what he does after it gets to him is his business, not DIDComm's. That's why we are comfortable with him using plaintext in a context wholly under his own control.)","title":"FAQ"},{"location":"faq/#intro","text":"This file will work as a lightweight frequently asked questions before it grows into something unmanagable and needs to have better structure on it. For now this will offer a simple content adressing list an link to each question. We have sections of questions and questions underneath each section. They link directly to each question.","title":"Intro"},{"location":"faq/#cryptography","text":"How kosher is it to do non encrypted messages?","title":"Cryptography"},{"location":"faq/#how-kosher-is-it-to-do-non-encrypted-messages","text":"Since it is an option to not encrypt DIDComm messages, and we want to be clear on how you can reason about it The answer to \"how kosher\" depends on two subquestions: Are you uninterested in confidentiality because the message is intended to be public anyway (e.g., it's a message inviting anyone in the general public to send you a message)? Will the message stay within trust domain boundaries? (That is, Alice sends an encrypted message to Bob; Bob decrypts and wants to send it as plaintext to 5 of his agents, but all of them are within his own sphere of control, and Bob trusts himself.) If the answer to either of these questions is \"Yes\", then we think non encrypted messages are completely fine. If the answer to both of these questions is \"No\", then we think messages should be encrypted, because it means confidentiality should matter. It might be tempting to say, \"True. But I'm using https, which gives confidentiality anyway.\" This is a fallacy, because by design a sender in DIDComm doesn't actually know the full route to the target. A sender might be using HTTPS, but perhaps part of the route is not. Using channel-oriented encryption (e.g., TLS) on the part of the channel you can see is not actually secure, if someone somewhere has to take plaintext off that channel and put it somewhere else that you don't know about. The guarantee is supposed to be end-to-end. (In our question #2 above, \"Bob\" is the end; what he does after it gets to him is his business, not DIDComm's. That's why we are comfortable with him using plaintext in a context wholly under his own control.)","title":"How kosher is it to do non encrypted messages?"},{"location":"helloencrypt/","text":"Build DIDComm messages Encrypted DIDComm message JVM Python RUST Unencrypted but signed DIDComm message JVM Python RUST Plaintext DIDComm message JVM Python RUST","title":"Build DIDComm messages"},{"location":"helloencrypt/#build-didcomm-messages","text":"","title":"Build DIDComm messages"},{"location":"helloencrypt/#encrypted-didcomm-message","text":"JVM Python RUST","title":"Encrypted DIDComm message"},{"location":"helloencrypt/#unencrypted-but-signed-didcomm-message","text":"JVM Python RUST","title":"Unencrypted but signed DIDComm message"},{"location":"helloencrypt/#plaintext-didcomm-message","text":"JVM Python RUST","title":"Plaintext DIDComm message"},{"location":"hellolibstools/","text":"Choosing libraries and tools This is a list of libraries and tools available to DIDComm developers. Much of this information comes from this IIW presentation and slides . Available Releases PyPi DIDComm Release PyPi Peer DID Release Maven DIDComm Release Maven Peer DID Release Crate DIDComm Release Reference Implementations These reference implementations provide a demonstration and examples in several programming languages. Python DIDComm Python Peer DID Python Java, Kotlin, Android DIDComm Java, Kotlin, Android Peer DID Java, Kotlin, Android RUST DIDComm RUST JavaScript/TypeScript via WASM iOS via wrapper is WIP other languages can be supported via wrappers Tools DIDComm v2 developers are contributing to projects that provide important tools for DIDComm v2. ECDH-1PU JVM Nimbus Jose JWT Python Authlib Rust Aries Askar DID rotation Forward protocol - Used by default for routing DIDComm messages. Python example Kotlin example RUST example Peer DID Static layers of support only (similar to did:key method). But more support for dynamic updates.","title":"Choosing libraries and tools"},{"location":"hellolibstools/#choosing-libraries-and-tools","text":"This is a list of libraries and tools available to DIDComm developers. Much of this information comes from this IIW presentation and slides .","title":"Choosing libraries and tools"},{"location":"hellolibstools/#available-releases","text":"PyPi DIDComm Release PyPi Peer DID Release Maven DIDComm Release Maven Peer DID Release Crate DIDComm Release","title":"Available Releases"},{"location":"hellolibstools/#reference-implementations","text":"These reference implementations provide a demonstration and examples in several programming languages. Python DIDComm Python Peer DID Python Java, Kotlin, Android DIDComm Java, Kotlin, Android Peer DID Java, Kotlin, Android RUST DIDComm RUST JavaScript/TypeScript via WASM iOS via wrapper is WIP other languages can be supported via wrappers","title":"Reference Implementations"},{"location":"hellolibstools/#tools","text":"DIDComm v2 developers are contributing to projects that provide important tools for DIDComm v2. ECDH-1PU JVM Nimbus Jose JWT Python Authlib Rust Aries Askar DID rotation Forward protocol - Used by default for routing DIDComm messages. Python example Kotlin example RUST example Peer DID Static layers of support only (similar to did:key method). But more support for dynamic updates.","title":"Tools"},{"location":"helloworldpy/","text":"\"Hello World\" in Python This simple \"Hello World\" example shows how Alice can create an encrypted message to Bob. In that case, we are using DIDComm Python and Peerdid Python libraries from SICPA . Step 1: Install packages Once you set up your python environment, you need to install the following packages: pip install didcomm pip install peerdid pip install json The code in the following sections can be executed in a single python file or executed online in this Binder interactive Jupyter notebook . Step 2: Imports First, we need to import all required functions, clases and types from didcomm and peerdid libraries as follows: from didcomm.common.types import DID, VerificationMethodType, VerificationMaterial, VerificationMaterialFormat from didcomm.did_doc.did_doc import DIDDoc, VerificationMethod, DIDCommService from didcomm.did_doc.did_resolver import DIDResolver from didcomm.message import Message from didcomm.secrets.secrets_resolver_demo import SecretsResolverDemo from didcomm.unpack import unpack, UnpackResult from didcomm.common.resolvers import ResolversConfig from didcomm.pack_encrypted import pack_encrypted, PackEncryptedConfig, PackEncryptedResult from didcomm.secrets.secrets_util import generate_x25519_keys_as_jwk_dict, generate_ed25519_keys_as_jwk_dict, jwk_to_secret from peerdid import peer_did from peerdid.did_doc import DIDDocPeerDID from peerdid.types import VerificationMaterialAuthentication, VerificationMethodTypeAuthentication, VerificationMaterialAgreement, VerificationMethodTypeAgreement, VerificationMaterialFormatPeerDID import json Step 3: Resolvers In this step we add two Resolvers needed by DIDComm and the libraries: Secret resolver: This sample code needs a storage to keep the generated key pair secrets. It will then be referenced by the library as a secrets_resolver . We can instantiate it as follows: secrets_resolver = SecretsResolverDemo() Note that the SecretsResolverDemo simply stores the keys in a text file named secrets.json . As you've just realized, this secret storage is anything but secure. Keep in mind that securing keys is of utmost importance for a self-sovereign identity; never use it in production. DID Resolver: DIDComm only works if your code knows how to resolve DIDs to DID documents. There are various libraries that provide that feature. For example, the Universal Resolver can be used. In this walk-through, we'll provide a simple stub that minimizes dependencies and keeps things as simple as possible. Click here for full example where you'll find the code that do the trick. Step 4: Create DIDs Using create_simple_peer_did helper function, Alice and Bob can create their DID Peer that they will share and use when communicating privately between each other. This function creates a basic DID Peer with only one Agreement key, one Authentication key, and no Service part. You can find the helper function and the full code here . alice_did = await create_simple_peer_did() print(\"Alice's DID:\", alice_did) bob_did = await create_simple_peer_did() print(\"Bob's DID:\", bob_did) You should get something similar to: Alice's DID: did:peer:2.Ez6LSt4Jscr227NFyuzKHT85haVE4AFVXm1tDwYeZ5xenxMmW.Vz6MkfvwnoNS6Cto38MEMbqdnypVDN7gS4oAMaHFkjAUse5JE Bob's DID: did:peer:2.Ez6LSetXDUvD8rBSei5TU5ew7VRdWyNBr5mAsxr6EoHFTxt9f.Vz6Mkty3Nu98rnrHfk1GBCurF7EFKY5Vb34FAJNJCMhwzduk3 Remember that while creating these simple DIDs, our helper function also stores the private keys in the secrets_resolver . In a real implementation, Alice will have her own secure store in her own wallet, and Bob will have a separated secure store in his own wallet. Also, those Peer DIDs can be resolved into DID documents that contain the Authentication and Agreement public keys. Step 5: Encrypt and pack the message Alice can create a simple \"Hello World\" message with: message = Message( body = {\"msg\": \"Hello World\"}, id = \"unique-id-24160d23ed1d\", type = \"my-protocol/1.0\", frm = alice_did, to = [bob_did] ) Note that the message includes an id that is mandatory and has to be unique to Alice. Also includes a type , also mandatory, that points to the protocol identifier that we've just invented. The body contains the actual message in an structured way associated by our my-protocol/1.0 . Attributes from and to are optional. Beware that in the code above the property from was replaced by frm due to a conflict of reserved words in Python; the conversion to the correct property ( from ) is handled internally by the library. DIDComm defines three message formats: plaintext, signed, and encrypted. We are going to use the latter since it is the most common for most applications. In that case, the message will be encrypted so only Bob can see it. The final packed message can be generated with this code: packed_msg = await pack_encrypted( resolvers_config = ResolversConfig( secrets_resolver = secrets_resolver, did_resolver = DIDResolverPeerDID() ), message = message, frm = alice_did, to = bob_did, sign_frm = None, pack_config = PackEncryptedConfig(protect_sender_id=False) ) This library also offers the option of anonymous encryption, encryption with no repudation, and message signing. Note also that we pass a resolver configuration pointing to our secrets store and the DID resolver. If you take a look at the packed message, you'll see that the content was hidden in the encryption: print(packed_msg.packed_msg[:200]+\"...\") {\"protected\":\"eyJ0eXAiOiJhcHBsaWNhdGlvbi9kaWRjb21tLWVuY3J5cHRlZCtqc29uIiwiYWxnIjoiRUNESC0xUFUrQTI1NktXIiwiZW5jIjoiQTI1NkNCQy1IUzUxMiIsImFwdSI6IlpHbGtPbkJsWlhJNk1pNUZlalpNVTNJM1pWaFlObXBxYjI0MFpFVmFWaz... Step 6: Receive and unpack the message Alice will send the packed message to Bob using a transport. Once received, Bob can unpack it with the following code: unpack_msg = await unpack( resolvers_config=ResolversConfig( secrets_resolver=secrets_resolver, did_resolver=DIDResolverPeerDID() ), packed_msg=packed_msg.packed_msg ) Note that we also passed the resolver config as before. Finally, Bob can see Alice's message by: print(unpack_msg.message.body[\"msg\"]) Hello World","title":"Helloworldpy"},{"location":"helloworldpy/#hello-world-in-python","text":"This simple \"Hello World\" example shows how Alice can create an encrypted message to Bob. In that case, we are using DIDComm Python and Peerdid Python libraries from SICPA .","title":"\"Hello World\" in Python"},{"location":"helloworldpy/#step-1-install-packages","text":"Once you set up your python environment, you need to install the following packages: pip install didcomm pip install peerdid pip install json The code in the following sections can be executed in a single python file or executed online in this Binder interactive Jupyter notebook .","title":"Step 1: Install packages"},{"location":"helloworldpy/#step-2-imports","text":"First, we need to import all required functions, clases and types from didcomm and peerdid libraries as follows: from didcomm.common.types import DID, VerificationMethodType, VerificationMaterial, VerificationMaterialFormat from didcomm.did_doc.did_doc import DIDDoc, VerificationMethod, DIDCommService from didcomm.did_doc.did_resolver import DIDResolver from didcomm.message import Message from didcomm.secrets.secrets_resolver_demo import SecretsResolverDemo from didcomm.unpack import unpack, UnpackResult from didcomm.common.resolvers import ResolversConfig from didcomm.pack_encrypted import pack_encrypted, PackEncryptedConfig, PackEncryptedResult from didcomm.secrets.secrets_util import generate_x25519_keys_as_jwk_dict, generate_ed25519_keys_as_jwk_dict, jwk_to_secret from peerdid import peer_did from peerdid.did_doc import DIDDocPeerDID from peerdid.types import VerificationMaterialAuthentication, VerificationMethodTypeAuthentication, VerificationMaterialAgreement, VerificationMethodTypeAgreement, VerificationMaterialFormatPeerDID import json","title":"Step 2: Imports"},{"location":"helloworldpy/#step-3-resolvers","text":"In this step we add two Resolvers needed by DIDComm and the libraries: Secret resolver: This sample code needs a storage to keep the generated key pair secrets. It will then be referenced by the library as a secrets_resolver . We can instantiate it as follows: secrets_resolver = SecretsResolverDemo() Note that the SecretsResolverDemo simply stores the keys in a text file named secrets.json . As you've just realized, this secret storage is anything but secure. Keep in mind that securing keys is of utmost importance for a self-sovereign identity; never use it in production. DID Resolver: DIDComm only works if your code knows how to resolve DIDs to DID documents. There are various libraries that provide that feature. For example, the Universal Resolver can be used. In this walk-through, we'll provide a simple stub that minimizes dependencies and keeps things as simple as possible. Click here for full example where you'll find the code that do the trick.","title":"Step 3: Resolvers"},{"location":"helloworldpy/#step-4-create-dids","text":"Using create_simple_peer_did helper function, Alice and Bob can create their DID Peer that they will share and use when communicating privately between each other. This function creates a basic DID Peer with only one Agreement key, one Authentication key, and no Service part. You can find the helper function and the full code here . alice_did = await create_simple_peer_did() print(\"Alice's DID:\", alice_did) bob_did = await create_simple_peer_did() print(\"Bob's DID:\", bob_did) You should get something similar to: Alice's DID: did:peer:2.Ez6LSt4Jscr227NFyuzKHT85haVE4AFVXm1tDwYeZ5xenxMmW.Vz6MkfvwnoNS6Cto38MEMbqdnypVDN7gS4oAMaHFkjAUse5JE Bob's DID: did:peer:2.Ez6LSetXDUvD8rBSei5TU5ew7VRdWyNBr5mAsxr6EoHFTxt9f.Vz6Mkty3Nu98rnrHfk1GBCurF7EFKY5Vb34FAJNJCMhwzduk3 Remember that while creating these simple DIDs, our helper function also stores the private keys in the secrets_resolver . In a real implementation, Alice will have her own secure store in her own wallet, and Bob will have a separated secure store in his own wallet. Also, those Peer DIDs can be resolved into DID documents that contain the Authentication and Agreement public keys.","title":"Step 4: Create DIDs"},{"location":"helloworldpy/#step-5-encrypt-and-pack-the-message","text":"Alice can create a simple \"Hello World\" message with: message = Message( body = {\"msg\": \"Hello World\"}, id = \"unique-id-24160d23ed1d\", type = \"my-protocol/1.0\", frm = alice_did, to = [bob_did] ) Note that the message includes an id that is mandatory and has to be unique to Alice. Also includes a type , also mandatory, that points to the protocol identifier that we've just invented. The body contains the actual message in an structured way associated by our my-protocol/1.0 . Attributes from and to are optional. Beware that in the code above the property from was replaced by frm due to a conflict of reserved words in Python; the conversion to the correct property ( from ) is handled internally by the library. DIDComm defines three message formats: plaintext, signed, and encrypted. We are going to use the latter since it is the most common for most applications. In that case, the message will be encrypted so only Bob can see it. The final packed message can be generated with this code: packed_msg = await pack_encrypted( resolvers_config = ResolversConfig( secrets_resolver = secrets_resolver, did_resolver = DIDResolverPeerDID() ), message = message, frm = alice_did, to = bob_did, sign_frm = None, pack_config = PackEncryptedConfig(protect_sender_id=False) ) This library also offers the option of anonymous encryption, encryption with no repudation, and message signing. Note also that we pass a resolver configuration pointing to our secrets store and the DID resolver. If you take a look at the packed message, you'll see that the content was hidden in the encryption: print(packed_msg.packed_msg[:200]+\"...\") {\"protected\":\"eyJ0eXAiOiJhcHBsaWNhdGlvbi9kaWRjb21tLWVuY3J5cHRlZCtqc29uIiwiYWxnIjoiRUNESC0xUFUrQTI1NktXIiwiZW5jIjoiQTI1NkNCQy1IUzUxMiIsImFwdSI6IlpHbGtPbkJsWlhJNk1pNUZlalpNVTNJM1pWaFlObXBxYjI0MFpFVmFWaz...","title":"Step 5: Encrypt and pack the message"},{"location":"helloworldpy/#step-6-receive-and-unpack-the-message","text":"Alice will send the packed message to Bob using a transport. Once received, Bob can unpack it with the following code: unpack_msg = await unpack( resolvers_config=ResolversConfig( secrets_resolver=secrets_resolver, did_resolver=DIDResolverPeerDID() ), packed_msg=packed_msg.packed_msg ) Note that we also passed the resolver config as before. Finally, Bob can see Alice's message by: print(unpack_msg.message.body[\"msg\"]) Hello World","title":"Step 6: Receive and unpack the message"},{"location":"human_communication_tech_vertical/","text":"DIDComm for Human Communication DIDComm Protocols for Human Communication allow for the interactions between two parting using human focused communication. Related Protocols Note that DIDComm allows the use of various protocols between parties. These human oriented communication protocols blend well with protocols of many other types, including but not limited to Verifiable Credentials and other forms of data exchange. Basic Message Allows bidirectional chat based communication. Either party can send messages. Supports language indication to allow for translation. Purposefully simple. Question Answer Facilitates the asking and answering of fixed answer questions. This is typically between a human and a service, allowing the service to customize flows based on user selections. Action Menu Provides a menu and basic form interface between parties. This is typically between a human and a service, allowing the human to be aware of and invoke process flows provided by the service. Additional Protocol Development DIDComm supports the development of additional protocols. Creating a new protocol and promoting it can add useful funcationality into the ecosystem. Support for these protocols can be detected with the Discover Features protocol when communicating with other software.","title":"DIDComm for Human Communication"},{"location":"human_communication_tech_vertical/#didcomm-for-human-communication","text":"DIDComm Protocols for Human Communication allow for the interactions between two parting using human focused communication.","title":"DIDComm for Human Communication"},{"location":"human_communication_tech_vertical/#related-protocols","text":"Note that DIDComm allows the use of various protocols between parties. These human oriented communication protocols blend well with protocols of many other types, including but not limited to Verifiable Credentials and other forms of data exchange.","title":"Related Protocols"},{"location":"human_communication_tech_vertical/#basic-message","text":"Allows bidirectional chat based communication. Either party can send messages. Supports language indication to allow for translation. Purposefully simple.","title":"Basic Message"},{"location":"human_communication_tech_vertical/#question-answer","text":"Facilitates the asking and answering of fixed answer questions. This is typically between a human and a service, allowing the service to customize flows based on user selections.","title":"Question Answer"},{"location":"human_communication_tech_vertical/#action-menu","text":"Provides a menu and basic form interface between parties. This is typically between a human and a service, allowing the human to be aware of and invoke process flows provided by the service.","title":"Action Menu"},{"location":"human_communication_tech_vertical/#additional-protocol-development","text":"DIDComm supports the development of additional protocols. Creating a new protocol and promoting it can add useful funcationality into the ecosystem. Support for these protocols can be detected with the Discover Features protocol when communicating with other software.","title":"Additional Protocol Development"},{"location":"intro/","text":"Implementers Guide This guide contains concepts, explanations, and important considerations for those building DIDComm capable systems.","title":"Implementers Guide"},{"location":"intro/#implementers-guide","text":"This guide contains concepts, explanations, and important considerations for those building DIDComm capable systems.","title":"Implementers Guide"},{"location":"migratorscript/","text":"V1 --> v2 migrator script Header and decorator mappings v1 v2 Notes @id id @type type ~thread.thid thid ~thread.pthid pthid ~thread.sender_order sender_order see Advanced Sequencing Extension ~thread.received_orders received_order see Advanced Sequencing Extension ~thread.goal_code body.goal_code goal_code body.goal_code goal body.goal ~l10n l10n see L10n Extension ~transport.return_route return_route see Return-Route Extension ~timing.expires_time expires_time v1 use timestamp format as \"2019-01-25 18:25Z\", v2 use unixtime seconds since 1970-01-01T00:00:00Z sent_time created_time v1 use timestamp format as \"2019-01-25 18:25Z\", v2 use unixtime seconds since 1970-01-01T00:00:00Z handler handler ~trace trace ~attach attachments an array of attachments ~attach[n].@id attachments[n].id ~attach[n].mime_type attachments[n].media_type ~attach[n].filename attachments[n].filename ~attach[n].description attachments[n].description ~attach[n].lastmod_time attachments[n].lastmod_time ~attach[n].byte_count attachments[n].byte_count ~attach[n].filename attachments[n].filename ~attach[n].data attachments[n].data ~attach[n].data.jws attachments[n].data.jws ~attach[n].data.sha256 attachments[n].data.hash ~attach[n].data.links attachments[n].data.links ~attach[n].data.base64 attachments[n].data.base64 ~attach[n].data.json attachments[n].data.json problem_code body.code in Problem Report Protocol comment body.comment in Problem Report Protocol","title":"V1 --> v2 migrator script"},{"location":"migratorscript/#v1-v2-migrator-script","text":"","title":"V1 --&gt; v2 migrator script"},{"location":"migratorscript/#header-and-decorator-mappings","text":"v1 v2 Notes @id id @type type ~thread.thid thid ~thread.pthid pthid ~thread.sender_order sender_order see Advanced Sequencing Extension ~thread.received_orders received_order see Advanced Sequencing Extension ~thread.goal_code body.goal_code goal_code body.goal_code goal body.goal ~l10n l10n see L10n Extension ~transport.return_route return_route see Return-Route Extension ~timing.expires_time expires_time v1 use timestamp format as \"2019-01-25 18:25Z\", v2 use unixtime seconds since 1970-01-01T00:00:00Z sent_time created_time v1 use timestamp format as \"2019-01-25 18:25Z\", v2 use unixtime seconds since 1970-01-01T00:00:00Z handler handler ~trace trace ~attach attachments an array of attachments ~attach[n].@id attachments[n].id ~attach[n].mime_type attachments[n].media_type ~attach[n].filename attachments[n].filename ~attach[n].description attachments[n].description ~attach[n].lastmod_time attachments[n].lastmod_time ~attach[n].byte_count attachments[n].byte_count ~attach[n].filename attachments[n].filename ~attach[n].data attachments[n].data ~attach[n].data.jws attachments[n].data.jws ~attach[n].data.sha256 attachments[n].data.hash ~attach[n].data.links attachments[n].data.links ~attach[n].data.base64 attachments[n].data.base64 ~attach[n].data.json attachments[n].data.json problem_code body.code in Problem Report Protocol comment body.comment in Problem Report Protocol","title":"Header and decorator mappings"},{"location":"mitm/","text":"DIDComm and Man-in-the-Middle (Content to be added here. See https://j.mp/3BzImtr)","title":"Mitm"},{"location":"mitm/#didcomm-and-man-in-the-middle","text":"(Content to be added here. See https://j.mp/3BzImtr)","title":"DIDComm and Man-in-the-Middle"},{"location":"mobileagents/","text":"Dealing with mobile agents Mobile agents are a key component in many decentralized identity solutions. Individuals holding Identity Wallets on their mobile phones, and IoT devices transmitting secure information from remote locations are some common examples of mobile agents. The ability to roam from different networks and change connectivity seamlessly is a great feature. However it comes at the expense that agents are unable to declare a unique network address where to be reached. Also, that obstacle becomes more complex when agents are hidden inside network firewalls. Additionally, DIDComm Messaging specifies that: * Transports are simplex , they only transfer messages from sender to receiver. No information about the effects or results from a message is transmitted over the same connection. * Parties may declare a serviceEndpoint in their DID Document. However DID Documents are mainly static and updating them, if possible, is not an instant process. Given the above mentioned situation, the question is how a mobile agent can receive a DIDComm message The answer is Routing Protocol 2.0 , that can be also complemented by the Return-Route extension. Routing Protocol The Routing Protocol defines a partially trusted party called Mediator to facilitate message delivery. Senders can pass messages to a mediator, so next, the mediator can forward them to the final destination. Of course, the final message to the receiver is encrypted and obscured to the intermediate mediator or mediators. Message from the sender to the mediator is of type forward and contains the encrypted messages to the receiver as attachments . Also, by this means, recipients can declare a mediator's serviceEndpoint as its own serviceEndpoint to receive messages. Return Route Althougt not fully necessary to solve the mobile agent problem, the Return-Route extension facilitates the communication by enabling bi-directional communication on the same transport, even when one party has no public endpoint. Messages can flow back in response to inbound messages over the same connection. That means that if the return-route header is present in a message with a value different to none , the receiver of a message can reply back in the same channel that was already established without the need to expose an endpoint. Solution via Mediator With those two elements a solution can be developed to cope with our problem. The process can be described as follow: 1. The mobile agent sends a message to register to a Mediator following a predefined protocol called Mediator Coordinator Protocol . The message must contain the return-route header. 2. The Mediator responds back to the mobile agent in the same channel that was already opened in the first step. In the response, the mediator assigns a own serviceEndpoint to the mobile agent, that later can be used in when sending messages to other parties. 3. Those third parties, when receiving a message from the mobile agent, can respond using the Routing Protocol by sending a forward message to the Mediator that contains the encrypted response to the mobile agent as an attachment. 4. The Mediator should hold the message, since there is no way to pass it to the mobile agent directly. 5. Using a predefined protocol called Pickup Protocol , the mobile agent contacts the Mediator who can respond back in the same channel forwarding all held messages from third parties.","title":"Dealing with mobile agents"},{"location":"mobileagents/#dealing-with-mobile-agents","text":"Mobile agents are a key component in many decentralized identity solutions. Individuals holding Identity Wallets on their mobile phones, and IoT devices transmitting secure information from remote locations are some common examples of mobile agents. The ability to roam from different networks and change connectivity seamlessly is a great feature. However it comes at the expense that agents are unable to declare a unique network address where to be reached. Also, that obstacle becomes more complex when agents are hidden inside network firewalls. Additionally, DIDComm Messaging specifies that: * Transports are simplex , they only transfer messages from sender to receiver. No information about the effects or results from a message is transmitted over the same connection. * Parties may declare a serviceEndpoint in their DID Document. However DID Documents are mainly static and updating them, if possible, is not an instant process. Given the above mentioned situation, the question is how a mobile agent can receive a DIDComm message The answer is Routing Protocol 2.0 , that can be also complemented by the Return-Route extension.","title":"Dealing with mobile agents"},{"location":"mobileagents/#routing-protocol","text":"The Routing Protocol defines a partially trusted party called Mediator to facilitate message delivery. Senders can pass messages to a mediator, so next, the mediator can forward them to the final destination. Of course, the final message to the receiver is encrypted and obscured to the intermediate mediator or mediators. Message from the sender to the mediator is of type forward and contains the encrypted messages to the receiver as attachments . Also, by this means, recipients can declare a mediator's serviceEndpoint as its own serviceEndpoint to receive messages.","title":"Routing Protocol"},{"location":"mobileagents/#return-route","text":"Althougt not fully necessary to solve the mobile agent problem, the Return-Route extension facilitates the communication by enabling bi-directional communication on the same transport, even when one party has no public endpoint. Messages can flow back in response to inbound messages over the same connection. That means that if the return-route header is present in a message with a value different to none , the receiver of a message can reply back in the same channel that was already established without the need to expose an endpoint.","title":"Return Route"},{"location":"mobileagents/#solution-via-mediator","text":"With those two elements a solution can be developed to cope with our problem. The process can be described as follow: 1. The mobile agent sends a message to register to a Mediator following a predefined protocol called Mediator Coordinator Protocol . The message must contain the return-route header. 2. The Mediator responds back to the mobile agent in the same channel that was already opened in the first step. In the response, the mediator assigns a own serviceEndpoint to the mobile agent, that later can be used in when sending messages to other parties. 3. Those third parties, when receiving a message from the mobile agent, can respond using the Routing Protocol by sending a forward message to the Mediator that contains the encrypted response to the mobile agent as an attachment. 4. The Mediator should hold the message, since there is no way to pass it to the mobile agent directly. 5. Using a predefined protocol called Pickup Protocol , the mobile agent contacts the Mediator who can respond back in the same channel forwarding all held messages from third parties.","title":"Solution via Mediator"},{"location":"oidc/","text":"OID4VC DIDComm is often compared with OpenID for Verifiable Credentials (OID4VC). These protocols do have overlapping concerns as related to Verifiable Credentials, but approach the exchange of them differently. In addition to the similarities, the each have some unique and useful properties. Password Friendly Security Model The flow of OID4VC allows for an iframe to be used for the verification of a password or other secrets. This allows the user to authenticate to the Identity Provider (IdP) without the Relying Party (RP) being able to observe the exchange. This is really the sweet spot for OpenID, and has been carried to the VC exchange protocols as well. DIDComm does not currently have a direct replacement for this flow. Different Connection Model The OpenID based flow doesn't allow for very effective communication without the user in the loop. This is sometimes desirable, but limits it's applicability for more automated flows. DIDComm has the ability to transfer messages without involvement of the user, when applicable. Message Types DIDComm has the built-in ability to transfer protocol messages of any type, not only those concerned with the issuance or verification of Verifiable Credentials. This allows for richer interaction beyond the uses focused on Verifable Credentials. Combined Use The different properties of the protocols make them very useful to each other. When exchanging a credential with OID4VC, a DID is often passed. If that DID resolves to a DID Document with a DIDComm Service Endpoint, then future, rich interactions can be continued via DIDComm. If the parties in a DIDComm relationship need to verify identity via secret checking with an RP, they can lean on OID4VC (or OpenID, if a credential is not involved) for that interaction.","title":"Oidc"},{"location":"oidc/#oid4vc","text":"DIDComm is often compared with OpenID for Verifiable Credentials (OID4VC). These protocols do have overlapping concerns as related to Verifiable Credentials, but approach the exchange of them differently. In addition to the similarities, the each have some unique and useful properties.","title":"OID4VC"},{"location":"oidc/#password-friendly-security-model","text":"The flow of OID4VC allows for an iframe to be used for the verification of a password or other secrets. This allows the user to authenticate to the Identity Provider (IdP) without the Relying Party (RP) being able to observe the exchange. This is really the sweet spot for OpenID, and has been carried to the VC exchange protocols as well. DIDComm does not currently have a direct replacement for this flow.","title":"Password Friendly Security Model"},{"location":"oidc/#different-connection-model","text":"The OpenID based flow doesn't allow for very effective communication without the user in the loop. This is sometimes desirable, but limits it's applicability for more automated flows. DIDComm has the ability to transfer messages without involvement of the user, when applicable.","title":"Different Connection Model"},{"location":"oidc/#message-types","text":"DIDComm has the built-in ability to transfer protocol messages of any type, not only those concerned with the issuance or verification of Verifiable Credentials. This allows for richer interaction beyond the uses focused on Verifable Credentials.","title":"Message Types"},{"location":"oidc/#combined-use","text":"The different properties of the protocols make them very useful to each other. When exchanging a credential with OID4VC, a DID is often passed. If that DID resolves to a DID Document with a DIDComm Service Endpoint, then future, rich interactions can be continued via DIDComm. If the parties in a DIDComm relationship need to verify identity via secret checking with an RP, they can lean on OID4VC (or OpenID, if a credential is not involved) for that interaction.","title":"Combined Use"},{"location":"pfs/","text":"Perfect Forward Secrecy A cryptographic method exhibits perfect forward secrecy (PFS) if the compromise of long-term keys does not allow an attacker to read old messages. The secrecy of the old messages persists forward in time. See the Wikipedia article , and also section 6.2 of this academic article . This property is valuable to the extent that comm channels are long-lasting and carry many interactions. DIDComm does not achieve this property under the familiar definition, because it lacks a session construct that defines how to interpret a phrase like \"long-term keys\" and \"session keys.\" Whether DIDComm achieves comparable goals is perhaps more interesting. In TLS, session keys are symmetric keys negotiated during a Diffie-Hellman handshake at the beginning of a series of request-response interactions that cluster together . Browsers running HTTPS \u2014 the most familiar embodiment of TLS \u2014 typically do a new DH exchange each time a tab is opened to a site's initial page, but not for subsequent requests to fetch graphics, scripts, CSS files, or the content and collateral of subsequent pages. Cryptographic sessions (not to be confused with cookie-based login sessions) may be re-established whenever a socket is re-opened (possibly at intervals only a few seconds apart), or may use techniques like TLS Session Resumption to last for hours or even days. A simple analysis of DIDComm might map PFS \"session keys\" to the ephemeral symmetric keys negotiated by the ECDH-1PU key agreement algorithm; this might imply that the static keys in Alice's DID doc would be the \"long-term keys\" from the PFS definition. In this framing, DIDComm does NOT exhibit PFS, because an attacker that possesses a key from Alice's DID doc can decrypt any old messages sent to that key. But this analysis misses two important insights: The ephemeral symmetric keys in TLS are two-way and reusable. It makes sense to call them \"session\" keys. In contrast, the ephemeral symmetric keys negotiated by ECDH-1PU in DIDComm are one-way and single-use only. Calling a one-way delivery of a single message a \"session\" seems a bit odd. The natural unit of clustered interaction in DIDComm \u2014 what we use \"sessions\" for in TLS, and what lasts seconds to minutes or hours \u2014 is a single protocol or group of protocols that accomplish one goal for the parties. This is a higher level of abstraction that a single DIDComm message. Only one compromise is contemplated by normal PFS \u2014 the compromise of a single long-term key. But DIDComm is more dynamic. It supports two types of rotation \u2014 rotation of DID doc keys and rotation of DIDs themselves. Moreover, DIDComm supports multiple devices per party, and it encourages the use of pairwise DIDs with a limited lifespan, often not exceeding a single interaction. It is the value of historic communication that makes PFS valuable. If DIDComm throws away DIDs after a single brief interaction, then PFS is irrelevant. If DIDComm rotates DIDs on the same time scales as static key rotation in TLS, then it is a DID's comm history, not Alice's (DID-spanning) comm history, that's endangered by a compromise. And if Alice has a stable DID but updates her DID doc regularly to track an evolving collection of devices, then her vulnerability to long-term key compromise doesn't map very well to the simpler PFS model. Here are two alternate analyses that suggest DIDComm accomplishes the goals of PFS, even if its approach is unfamiliar. We do NOT advocate these analyses as objectively \"true\" \u2014 they are mutually incompatible, and unless/until formal definitions are satisfied, it is clearly unwise to rely on loose assertions about cryptographic guarantees. Rather, the point of including them here is to illustrate the importance of assumptions. PFS Reframe 1 In some DIDComm usages, \"sessions\" might have the same scope as DIDs, and \"long-term keys\" might have the same scope as a multi-DID-spanning connection between two parties. A compromise of the second \"long-term key\" (DID and associated keys for all her devices) used by Alice in her relationship with Bob would allow an attacker to read everything sent to Alice in that session (while she was using DID #2). However, it wouldn't let the attacker read anything sent to Alice in the previous sessions (with previous DID values). DIDComm would thus accomplish the same goals as perfect forward secrecy. PFS Reframe 2 In other DIDComm usages, \"sessions\" might have the same scope as a single snapshot of the key agreement keys in a DID doc, and \"long-term keys\" would be the signing keys that authorize updates to a new set of key agreement keys. A compromise of long-term keys would not allow the attacker to decrypt any historical communication at all. DIDComm would thus accomplish the same goals as perfect forward secrecy. Thus, the guidance on perfect forward secrecy with respect to DIDComm is simple: Understand your goals and your assumptions. Consider questions like these: What is the intended lifespan of a DID in your DIDComm usage patterns? How often are its keys (both encryption and signing) rotated \u2014 and with what purposes? DIDComm allows various answers to these questions; depending on the answers, it may or may not provide enough built-in protection of old communication at the point of a future compromise.","title":"Pfs"},{"location":"pfs/#perfect-forward-secrecy","text":"A cryptographic method exhibits perfect forward secrecy (PFS) if the compromise of long-term keys does not allow an attacker to read old messages. The secrecy of the old messages persists forward in time. See the Wikipedia article , and also section 6.2 of this academic article . This property is valuable to the extent that comm channels are long-lasting and carry many interactions. DIDComm does not achieve this property under the familiar definition, because it lacks a session construct that defines how to interpret a phrase like \"long-term keys\" and \"session keys.\" Whether DIDComm achieves comparable goals is perhaps more interesting. In TLS, session keys are symmetric keys negotiated during a Diffie-Hellman handshake at the beginning of a series of request-response interactions that cluster together . Browsers running HTTPS \u2014 the most familiar embodiment of TLS \u2014 typically do a new DH exchange each time a tab is opened to a site's initial page, but not for subsequent requests to fetch graphics, scripts, CSS files, or the content and collateral of subsequent pages. Cryptographic sessions (not to be confused with cookie-based login sessions) may be re-established whenever a socket is re-opened (possibly at intervals only a few seconds apart), or may use techniques like TLS Session Resumption to last for hours or even days. A simple analysis of DIDComm might map PFS \"session keys\" to the ephemeral symmetric keys negotiated by the ECDH-1PU key agreement algorithm; this might imply that the static keys in Alice's DID doc would be the \"long-term keys\" from the PFS definition. In this framing, DIDComm does NOT exhibit PFS, because an attacker that possesses a key from Alice's DID doc can decrypt any old messages sent to that key. But this analysis misses two important insights: The ephemeral symmetric keys in TLS are two-way and reusable. It makes sense to call them \"session\" keys. In contrast, the ephemeral symmetric keys negotiated by ECDH-1PU in DIDComm are one-way and single-use only. Calling a one-way delivery of a single message a \"session\" seems a bit odd. The natural unit of clustered interaction in DIDComm \u2014 what we use \"sessions\" for in TLS, and what lasts seconds to minutes or hours \u2014 is a single protocol or group of protocols that accomplish one goal for the parties. This is a higher level of abstraction that a single DIDComm message. Only one compromise is contemplated by normal PFS \u2014 the compromise of a single long-term key. But DIDComm is more dynamic. It supports two types of rotation \u2014 rotation of DID doc keys and rotation of DIDs themselves. Moreover, DIDComm supports multiple devices per party, and it encourages the use of pairwise DIDs with a limited lifespan, often not exceeding a single interaction. It is the value of historic communication that makes PFS valuable. If DIDComm throws away DIDs after a single brief interaction, then PFS is irrelevant. If DIDComm rotates DIDs on the same time scales as static key rotation in TLS, then it is a DID's comm history, not Alice's (DID-spanning) comm history, that's endangered by a compromise. And if Alice has a stable DID but updates her DID doc regularly to track an evolving collection of devices, then her vulnerability to long-term key compromise doesn't map very well to the simpler PFS model. Here are two alternate analyses that suggest DIDComm accomplishes the goals of PFS, even if its approach is unfamiliar. We do NOT advocate these analyses as objectively \"true\" \u2014 they are mutually incompatible, and unless/until formal definitions are satisfied, it is clearly unwise to rely on loose assertions about cryptographic guarantees. Rather, the point of including them here is to illustrate the importance of assumptions.","title":"Perfect Forward Secrecy"},{"location":"pfs/#pfs-reframe-1","text":"In some DIDComm usages, \"sessions\" might have the same scope as DIDs, and \"long-term keys\" might have the same scope as a multi-DID-spanning connection between two parties. A compromise of the second \"long-term key\" (DID and associated keys for all her devices) used by Alice in her relationship with Bob would allow an attacker to read everything sent to Alice in that session (while she was using DID #2). However, it wouldn't let the attacker read anything sent to Alice in the previous sessions (with previous DID values). DIDComm would thus accomplish the same goals as perfect forward secrecy.","title":"PFS Reframe 1"},{"location":"pfs/#pfs-reframe-2","text":"In other DIDComm usages, \"sessions\" might have the same scope as a single snapshot of the key agreement keys in a DID doc, and \"long-term keys\" would be the signing keys that authorize updates to a new set of key agreement keys. A compromise of long-term keys would not allow the attacker to decrypt any historical communication at all. DIDComm would thus accomplish the same goals as perfect forward secrecy. Thus, the guidance on perfect forward secrecy with respect to DIDComm is simple: Understand your goals and your assumptions. Consider questions like these: What is the intended lifespan of a DID in your DIDComm usage patterns? How often are its keys (both encryption and signing) rotated \u2014 and with what purposes? DIDComm allows various answers to these questions; depending on the answers, it may or may not provide enough built-in protection of old communication at the point of a future compromise.","title":"PFS Reframe 2"},{"location":"privacy/","text":"Privacy This section discusses best practices and the implications of DIDComm Protocols on the privacy of the communicating parties. Public Fingerprinting Users should avoid disclosing supported protocols until sufficient trust has been established. The broad disclosure of supported protocols may provide a unique fingerprint that can be used to correlate multiple identifiers in use by a single party. DIDComm's use of the Discover Features Protocol allows selective disclosure of features to mitigate this problem. Leveraging this protocol as a better substitute for Verifiable Data Registry (VDR) published DID Document endpoints will prevent the disclosure of unique protocols.","title":"Privacy"},{"location":"privacy/#privacy","text":"This section discusses best practices and the implications of DIDComm Protocols on the privacy of the communicating parties.","title":"Privacy"},{"location":"privacy/#public-fingerprinting","text":"Users should avoid disclosing supported protocols until sufficient trust has been established. The broad disclosure of supported protocols may provide a unique fingerprint that can be used to correlate multiple identifiers in use by a single party. DIDComm's use of the Discover Features Protocol allows selective disclosure of features to mitigate this problem. Leveraging this protocol as a better substitute for Verifiable Data Registry (VDR) published DID Document endpoints will prevent the disclosure of unique protocols.","title":"Public Fingerprinting"},{"location":"problemcodes/","text":"Problem Codes Problems are reported by a specific message defined in the Problem Report 2.0 protocol. That message looks like this: { \"type\": \"https://didcomm.org/report-problem/2.0/problem-report\", \"id\": \"7c9de639-c51c-4d60-ab95-103fa613c805\", \"pthid\": \"1e513ad4-48c9-444e-9e7e-5b8b45c5e325\", \"ack\": [\"1e513ad4-48c9-444e-9e7e-5b8b45c5e325\"], \"body\": { \"code\": \"e.p.xfer.cant-use-endpoint\", \"comment\": \"Unable to use the {1} endpoint for {2}.\", \"args\": [ \"https://agents.r.us/inbox\", \"did:sov:C805sNYhMrjHiqZDTUASHg\" ], \"escalate_to\": \"mailto:admin@foo.org\" } } One of the most importan headers of that message is the code header that categorizes, in a machine readable format, what went wrong. code follows a structured format defined in Problem Codes on the specification. In short, the code is contructed as a sequence like: {sorter}.{scope}.{general_descriptor}.{specific_descriptor}.{more_specific_descriptor}.. {sorter} can be either e it is an error, or w id it is a warning. {scope} can be either p if belongs to a protocol, or m if it was triggered by a previous message. {descriptors} is a kebab-case sequence of descriptors separated by . where the semantics get progressively more detailed reading left to right. In this section we are listing a list of predefined codes that can be used by themselves, or as prefixes to more specific descriptors: Token Value of comment string Notes trust Failed to achieve required trust. Typically this code indicates incorrect or suboptimal behavior by the sender of a previous message in a protocol. For example, a protocol required a known sender but a message arrived anoncrypted instead \u2014 or the encryption is well formed and usable, but is considered weak. Problems with this descriptor are similar to those reported by HTTP's 401 , 403 , or 407 status codes. trust.crypto Cryptographic operation failed. A cryptographic operation cannot be performed, or it gives results that indicate tampering or incorrectness. For example, a key is invalid \u2014 or the key types used by another party are not supported \u2014 or a signature doesn't verify \u2014 or a message won't decrypt with the specified key. xfer Unable to transport data. The problem is with the mechanics of moving messages or associated data over a transport. For example, the sender failed to download an external attachment \u2014 or attempted to contact an endpoint, but found nobody listening on the specified port. did DID is unusable. A DID is unusable because its method is unsupported \u2014 or because its DID doc cannot be parsed \u2014 or because its DID doc lacks required data. msg Bad message. Something is wrong with content as seen by application-level protocols (i.e., in a plaintext message). For example, the message might lack a required field, use an unsupported version, or hold data with logical contradictions. Problems in this category resemble HTTP's 400 status code. me Internal error. The problem is with conditions inside the problem sender's system. For example, the sender is too busy to do the work entailed by the next step in the active protocol. Problems in this category resemble HTTP's 5xx status codes. me.res A required resource is inadequate or unavailable. The following subdescriptors are also defined: me.res.net , me.res.memory , me.res.storage , me.res.compute , me.res.money req Circumstances don't satisfy requirements. A behavior occurred out of order or without satisfying certain preconditions \u2014 or circumstances changed in a way that violates constraints. For example, a protocol that books plane tickets fails because, halfway through, it is discovered that all tickets on the flight have been sold. req.time Failed to satisfy timing constraints. A message has expired \u2014 or a protocol has timed out \u2014 or it is the wrong time of day/day of week. legal Failed for legal reasons. An injunction or a regulatory requirement prevents progress on the workflow. Compare HTTP status code 451 .","title":"Problem Codes"},{"location":"problemcodes/#problem-codes","text":"Problems are reported by a specific message defined in the Problem Report 2.0 protocol. That message looks like this: { \"type\": \"https://didcomm.org/report-problem/2.0/problem-report\", \"id\": \"7c9de639-c51c-4d60-ab95-103fa613c805\", \"pthid\": \"1e513ad4-48c9-444e-9e7e-5b8b45c5e325\", \"ack\": [\"1e513ad4-48c9-444e-9e7e-5b8b45c5e325\"], \"body\": { \"code\": \"e.p.xfer.cant-use-endpoint\", \"comment\": \"Unable to use the {1} endpoint for {2}.\", \"args\": [ \"https://agents.r.us/inbox\", \"did:sov:C805sNYhMrjHiqZDTUASHg\" ], \"escalate_to\": \"mailto:admin@foo.org\" } } One of the most importan headers of that message is the code header that categorizes, in a machine readable format, what went wrong. code follows a structured format defined in Problem Codes on the specification. In short, the code is contructed as a sequence like: {sorter}.{scope}.{general_descriptor}.{specific_descriptor}.{more_specific_descriptor}.. {sorter} can be either e it is an error, or w id it is a warning. {scope} can be either p if belongs to a protocol, or m if it was triggered by a previous message. {descriptors} is a kebab-case sequence of descriptors separated by . where the semantics get progressively more detailed reading left to right. In this section we are listing a list of predefined codes that can be used by themselves, or as prefixes to more specific descriptors: Token Value of comment string Notes trust Failed to achieve required trust. Typically this code indicates incorrect or suboptimal behavior by the sender of a previous message in a protocol. For example, a protocol required a known sender but a message arrived anoncrypted instead \u2014 or the encryption is well formed and usable, but is considered weak. Problems with this descriptor are similar to those reported by HTTP's 401 , 403 , or 407 status codes. trust.crypto Cryptographic operation failed. A cryptographic operation cannot be performed, or it gives results that indicate tampering or incorrectness. For example, a key is invalid \u2014 or the key types used by another party are not supported \u2014 or a signature doesn't verify \u2014 or a message won't decrypt with the specified key. xfer Unable to transport data. The problem is with the mechanics of moving messages or associated data over a transport. For example, the sender failed to download an external attachment \u2014 or attempted to contact an endpoint, but found nobody listening on the specified port. did DID is unusable. A DID is unusable because its method is unsupported \u2014 or because its DID doc cannot be parsed \u2014 or because its DID doc lacks required data. msg Bad message. Something is wrong with content as seen by application-level protocols (i.e., in a plaintext message). For example, the message might lack a required field, use an unsupported version, or hold data with logical contradictions. Problems in this category resemble HTTP's 400 status code. me Internal error. The problem is with conditions inside the problem sender's system. For example, the sender is too busy to do the work entailed by the next step in the active protocol. Problems in this category resemble HTTP's 5xx status codes. me.res A required resource is inadequate or unavailable. The following subdescriptors are also defined: me.res.net , me.res.memory , me.res.storage , me.res.compute , me.res.money req Circumstances don't satisfy requirements. A behavior occurred out of order or without satisfying certain preconditions \u2014 or circumstances changed in a way that violates constraints. For example, a protocol that books plane tickets fails because, halfway through, it is discovered that all tickets on the flight have been sold. req.time Failed to satisfy timing constraints. A message has expired \u2014 or a protocol has timed out \u2014 or it is the wrong time of day/day of week. legal Failed for legal reasons. An injunction or a regulatory requirement prevents progress on the workflow. Compare HTTP status code 451 .","title":"Problem Codes"},{"location":"problems/","text":"Timeouts It is a best practice to ponder appropriate timeout settings when designing application-level protocols atop DIDComm. A protocol for conducting live music over the internet should probably time out its messages to cue musicians within milliseconds, whereas a protocol to apply for college may need timeouts that are days or weeks long. A protocol definition should communicate timeout assumptions like these. Individual implementers of a protocol should also ponder whether they need timeouts more aggressive than those of the general community. Perhaps a college application protocol allows the process to unfold over weeks -- but an app that promises it can help someone apply to college in 5 minutes shouldn't use default timeouts in the messages it sends. Cybersecurity considerations for problem reports Ethical and unethical hackers deliberately trigger errors on systems to understand what exploits are possible. We expect this to happen with DIDComm. Therefore, the troubleshooting and transparency that comes from problem reports needs to be weighed against the risk of disclosing too much information. The following considerations are recommended. Problem reports do not have to be sent (only) to the party who triggers a problem. Sometimes, a different (or additional) audience may be appropriate. The problem-report message type is deliberately decoupled from the versioning and release status of other protocols, so it cannot be used for feature sniffing. Fields that encourage careless, recursive information dumping (e.g., Java's Throwable.cause ) do not appear in problem-report . The comment and args properties of a problem-report are separated, with comment mapping consistently to a code . This means that the risk of disclosing too much information is concentrated in the value of args , not comment . Values placed in args should be scrubbed of anything sensitive. Sending problem reports to an unknown party is more risky than sending them to someone with known characteristics. (Because DIDComm's normal mode is mutual authentication via DIDs, and because DIDComm connections may accumulate credential-based context, this is a manageable risk.) Sending problem reports immediately may be more risky than sending them with a modest, random delay. This makes denial-of-service attacks and temporal correlation harder, and is the same principle that motivates login dialogs to pause before reporting an incorrect password.","title":"Problems"},{"location":"problems/#timeouts","text":"It is a best practice to ponder appropriate timeout settings when designing application-level protocols atop DIDComm. A protocol for conducting live music over the internet should probably time out its messages to cue musicians within milliseconds, whereas a protocol to apply for college may need timeouts that are days or weeks long. A protocol definition should communicate timeout assumptions like these. Individual implementers of a protocol should also ponder whether they need timeouts more aggressive than those of the general community. Perhaps a college application protocol allows the process to unfold over weeks -- but an app that promises it can help someone apply to college in 5 minutes shouldn't use default timeouts in the messages it sends.","title":"Timeouts"},{"location":"problems/#cybersecurity-considerations-for-problem-reports","text":"Ethical and unethical hackers deliberately trigger errors on systems to understand what exploits are possible. We expect this to happen with DIDComm. Therefore, the troubleshooting and transparency that comes from problem reports needs to be weighed against the risk of disclosing too much information. The following considerations are recommended. Problem reports do not have to be sent (only) to the party who triggers a problem. Sometimes, a different (or additional) audience may be appropriate. The problem-report message type is deliberately decoupled from the versioning and release status of other protocols, so it cannot be used for feature sniffing. Fields that encourage careless, recursive information dumping (e.g., Java's Throwable.cause ) do not appear in problem-report . The comment and args properties of a problem-report are separated, with comment mapping consistently to a code . This means that the risk of disclosing too much information is concentrated in the value of args , not comment . Values placed in args should be scrubbed of anything sensitive. Sending problem reports to an unknown party is more risky than sending them to someone with known characteristics. (Because DIDComm's normal mode is mutual authentication via DIDs, and because DIDComm connections may accumulate credential-based context, this is a manageable risk.) Sending problem reports immediately may be more risky than sending them with a modest, random delay. This makes denial-of-service attacks and temporal correlation harder, and is the same principle that motivates login dialogs to pause before reporting an incorrect password.","title":"Cybersecurity considerations for problem reports"},{"location":"routing/","text":"Routing Routing is the process of managing the delivery of messages from sender to recipient, possibly adapting the packaging and transfer to intermediate nodes. A route is a map or plan that specifies enough to achieve delivery in at least one direction; it may omit uninteresting details. A sender emits a message hoping that a recipient eventually receives it. As a message moves toward the recipient, we say it is moving destward ; the opposite direction is sourceward . Note that sender and recipient flip if a request-like message is followed by a response-like message in the opposite direction; the context that defines a sender is a single message, not a paired interaction. (DIDComm supports request-response but does not require it.) We tend to conceive of senders and recipients as simple \u2014 \"Alice\" and \"Bob\" sound like unitary individuals. This can be a useful simplification. However, it's important to remember that it may hide important detail; if Bob uses a laptop, a mobile device, and a cloud service to receive messages, and if each of them follows the cryptographic best practice of not sharing keys, then it is impossible to ignore this complexity in some parts of routing design. We call the set of things that Bob controls his sovereign domain (or domain for short). Note that this usage is notably different from the meaning of \"domain\" in DNS and many web contexts. We also use the loose cover term agent to refer to individual devices or pieces of software inside a given domain. The boundary of a domain is an important construct for trust analysis and for routing. We will explore this in greater detail below. Routing Requirements All messaging technologies must address routing in some way. However, DIDComm has unusual requirements: Because of security and privacy goals, DIDComm routing must impose careful limits on how and to what degree intermediate nodes are trusted. Because DIDComm aims to be transport-independent, its routing model must be carefully decoupled from strong assumptions about networking. In particular, DIDComm routing cannot make broad-brush assumptions that: A given route will use only a single transport. Transport mechanisms will provide any security benefits. The identity and connectivity for every hop in a route will be known by any party at the time a message is sent. The route from sender to recipient will be similar in hop identity, hop count, or transport mix to a complementary route from recipient back to sender. All the nodes in a route are ever online at the same time. Because of decentralization and multiple-peer-friendly goals, DIDComm routing cannot orient itself around servers or simple request\u2014response patterns as mandatory components. Because of privacy goals, DIDComm must offer fine distinctions in how repudiation and authentication are handled. These requirements are very demanding. They do NOT necessarily make DIDComm hard to implement. They do NOT prevent DIDComm from using common web infrastructure \u2014 indeed, DIDComm routes quite simply and elegantly over HTTP. However, they DO force the routing model to be described in a very generic, flexible way, and they DO mean that existing routing solutions are an imperfect fit. DIDComm learns as much as it can, and borrows as much as it can, from clever and battle-tested routing work done in other contexts, but it does have some unique twists. Overview Let's focus on a simple case where A wants to send a message to B , and the route involves one intermediate hop at C . Suppressing a few details, DIDComm routing works like this: A prepares a plaintext message of any type, M[0] , and encrypts it for the recipient, B . This produces M[1] . A prepares another plaintext message of type forward , and adds M[1] to it as an attachment. This new message, M[2] , asks C to to deliver the attached payload to B . A encrypts M[2] for C , producing M[3] . A hands M[3] to C . C decrypts M[3] , producing M[2] . Reading the plaintext, C sees that it's been asked to deliver the encrypted attachment to B . C hands the attachment from M[2] \u2014 which is the encrypted message M[1] \u2014 to B . B decrypts M[1] , reproducing the plaintext M[0] . This is not the simplest possible scenario; DIDComm could be direct from A to C , which would eliminate steps 2-5. Some DIDComm+HTTP interactions are that simple. And it is not the most complex DIDComm routing scenario, either. Much more elaborate routes could be described by introducing additional hops with additional forward messages. However, the above sequence is a good rough model to carry through the discussion that follows. The forward message The forward message created in step 2 in our overview is a DIDComm application-level protocol message. Routing, as described here, is just one of many protocols that can be built atop DIDComm primitives. A and C are \"speaking\" this protocol when they communicate. The routing protocol can use the same features as any other application-level protocol; this includes attachments , message threading , message timing , message tracing , ACKs , problem reports , and so forth. However, before we describe the structure and semantics of the forward message in detail, it's important to understand some additional routing concepts. Two Dimensions Two dimensions of routing are relevant to DIDComm. Sometimes they are confused or conflated: Network routing deals with how packets flow across a digital landscape. This is the \"routing\" familiar to most technical people, and the one that will inform most assumptions they bring to the routing topic when reading the DIDComm spec for the first time. Cryptographic routing concerns itself with how packaging hides or reveals plaintext to participants in a delivery chain. In other words, it's about the routing of secrets rather than the routing of packets. The overview immediately above collapsed these two dimensions, assuming that a node relaying data is also a node decrypting. This makes for simple explanations, but it's not always a true or helpful assumption. The correspondence between these two routing dimensions can be non-trivial; a route may have ten network hops but only three cryptographic hops, and a single network hop may decrypt twice as it passes data between distinct software entities. However, simple principles explain the dynamics for each situation. Mediators and Relays DIDComm routing uses two important constructs to model all varieties of network and cryptographic routing: mediators and relays . A mediator is a participant in routing that must be accounted for by the sender's cryptography. In other words, it is visible in the cryptographic routing dimension. It has its own keys and will deliver messages only after decrypting an outer envelope to reveal a forward request. It must understand DIDComm routing to do this. Many types of mediators may exist, but two important ones should be widely understood, as they commonly manifest in DID Docs: A service that receives messages for many agents at a single endpoint to provide herd privacy (sometimes called an \"agency\") is a mediator . A cloud-based agent that forwards messages to mobile devices is a mediator . In contrast, a relay is an entity that passes along encrypted messages without understanding or decrypting them. It's focused on network routing only. Like mediators, relays can be used to change the transport for a message (e.g., accept an HTTP POST, then turn around and emit an email; accept a Bluetooth transmission, then turn around and emit something in a message queue). But unlike mediators, relays can do this without understanding DIDComm. Load balancers and mix networks like TOR are important types of relay. Let's define mediators and relays by exploring how they manifest in a series of communication scenarios between Alice and Bob. Scenario 1: direct Alice and Bob are both employees of a large corporation. They work in the same office, but have never met. The office has a rule that all messages between employees must be encrypted. They use paper messages and physical delivery as the transport. Alice writes a note, encrypts it so only Bob can read it, puts it in an envelope addressed to Bob, and drops the envelope on a desk that she has been told belongs to Bob. This desk is in fact Bob's, and he later picks up the message, decrypts it, and reads it. In this scenario, there is no mediator, and no relay. Scenario 2: a gatekeeper Imagine that Bob hires an executive assistant, Carl, to filter his mail. Bob won't open any mail unless Carl looks at it and decides that it's worthy of Bob's attention. Alice has to change her behavior. She continues to package a message for Bob, but now she must account for Carl as well. She take the envelope for Bob, and places it inside a new envelope addressed to Carl. Inside the outer envelope, and next to the envelope destined for Bob, Alice writes Carl an encrypted note: \"This inner envelope is for Bob. Please forward.\" Here, Carl is acting as a mediator . He is mostly just passing messages along. But because he is processing a message himself, and because Carl is interposed between Alice and Bob, he affects the behavior of the sender. He is a known entity in the route. You may recognize this as similar to our overview example with A, B, and C. A and B correspond to Alice and Bob; C is Carl, the mediator. Scenario 3: transparent indirection All is the same as the base scenario (Carl has been fired, and is thus out of the picture), except that Bob is working from home when Alice's message lands on his desk. Bob has previously arranged with his friend Darla, who lives near him, to pick up any mail that's on his desk and drop it off at his house at the end of the work day. Darla sees Alice's note and takes it home to Bob. In this scenario, Darla is acting as a relay . Note that Bob arranges for Darla to do this without notifying Alice , and that Alice does not need to adjust her behavior in any way for the relay to work . Scenario 4: more indirection Like scenario 3, Darla brings Bob his mail at home. However, Bob isn't at home when his mail arrives. He's had to rush out on an errand, but he's left instructions with his son, Emil, to open any work mail, take a photo of the letter, and text him the photo. Emil intends to do this, but the camera on his phone misfires, so he convinces his sister, Francis, to take the picture on her phone and email it to him. Then he texts the photo to Bob, as arranged. Here, Emil and Francis are also acting as relays. Note that nobody knows about the full route . Alice thinks she's delivering directly to Bob. So does Darla. Bob knows about Darla and Emil, but not about Francis. Note, too, how the transport is changing from physical mail to email to text. To the party immediately upstream (closer to the sender), a relay is indistinguishable from the next party downstream (closer to the recipient). A party anywhere in the chain can insert one or more relays upstream from themselves, as long as those relays are not upstream of another named party (sender or mediator). More Scenarios Mediators and relays can be combined in any order and any amount in variations on our fictional scenario. Bob could employ Carl as a mediator, and Carl could work from home and arrange delivery via George, then have his daughter Hannah run messages back to Bob's desk at work. Carl could hire his own mediator. Darla could arrange for Ivan to substitute for her when she goes on vacation. And so forth. More Traditional Usage The scenarios used above are somewhat artificial. Our most familiar routing scenarios involve edge agents running on mobile devices and accessible through bluetooth or push notification, and cloud agents that use electronic protocols as their transport. Let's see how relays and mediators apply there. Scenario 5: direct Alice's cloud wants to talk to Bob's cloud. Bob's cloud is listening at http://bob.com/api. Alice encrypts a message for Bob and posts it to that URL. In this scenario, we are using a direct transport with neither a mediator nor a relay. This is how Alice and Bob operate in Scenario 1, and it's also equivalent to our Overview minus steps 2-5. When DIDComm involves only two parties, and when HTTP is convenient for both of them, this sort of direct delivery may be used. (Note that if you need n-wise, or if you need a reciprocal return route but Alice's cloud exposes no public API, this delivery scenario can present problems. More on this later.) Virtually the same diagram could be used for a Bluetooth or NFC or sneakernet conversation that happens offline: Scenario 6: herd hosting Let's tweak Scenario 5 slightly by saying that Bob's agent is one of thousands that are hosted at the same URL. Maybe the URL is now http://agents-r-us.com/inbox. Now if Alice wants to talk to Bob's cloud agent, she has to cope with a mediator. She wraps the encrypted message for Bob's cloud agent inside a forward message that's addressed to and encrypted for the agent of agents-r-us that functions as a gatekeeper. This scenario is one that highlights an external mediator --so-called because the mediator lives outside the sovereign domain of the final recipient. Scenario 7: intra-domain dispatch Now let's subtract agents-r-us. We're back to Bob's cloud agent listening directly at http://bob.com/agent. However, let's say that Alice has a different goal--now she wants to talk to the edge agent running on Bob's mobile device. This agent doesn't have a permanent IP address, so Bob uses his own cloud agent as a mediator. He tells Alice that his mobile device agent can only be reached via his cloud agent. Once again, this causes Alice to modify her behavior. Again, she wraps her encrypted message. The inner message is enclosed in an outer envelope, and the outer envelope is passed to the mediator. This scenario highlights an internal mediator . Internal and external mediators introduce similar features and similar constraints; the relevant difference is that internal mediators live within the sovereign domain of the recipient, and may thus be worthy of greater trust. Scenario 8: double mediation Now let's combine. Bob's cloud agent is hosted at agents-r-us, AND Alice wants to reach Bob's mobile: This is a common pattern with HTTP-based cloud agents plus mobile edge agents, which is the most common deployment pattern we expect for many users of self-sovereign identity. Note that the properties of the agency and the routing agent are not particularly special--they are just an external and an internal mediator, respectively. Remember Routes are One-Way (not Duplex) In all of this discussion, note that we are analyzing only a flow from Alice to Bob. How Bob gets a message back to Alice is a completely separate question. Just because Carl, Darla, Emil, Francis, and Agents-R-Us may be involved in how messages flow from Alice to Bob, does not mean they are involved in flow the opposite direction. Note how this breaks the simple assumptions of pure request-response technologies like HTTP, that assume the channel in (request) is also the channel out (response). Duplex request-response can be modeled with DIDComm, but doing so requires support that may not always be available, plus cooperative behavior governed by the ~thread decorator. Routing Protocol Now that we understand mediators and relays, how and why they might be combined in various ways, and how their presence influences delivery semantics, we can describe the actual application-level routing protocol that any DIDComm sender speaks with a destward mediator. See [Routing Protocol] in the spec.","title":"Routing"},{"location":"routing/#routing","text":"Routing is the process of managing the delivery of messages from sender to recipient, possibly adapting the packaging and transfer to intermediate nodes. A route is a map or plan that specifies enough to achieve delivery in at least one direction; it may omit uninteresting details. A sender emits a message hoping that a recipient eventually receives it. As a message moves toward the recipient, we say it is moving destward ; the opposite direction is sourceward . Note that sender and recipient flip if a request-like message is followed by a response-like message in the opposite direction; the context that defines a sender is a single message, not a paired interaction. (DIDComm supports request-response but does not require it.) We tend to conceive of senders and recipients as simple \u2014 \"Alice\" and \"Bob\" sound like unitary individuals. This can be a useful simplification. However, it's important to remember that it may hide important detail; if Bob uses a laptop, a mobile device, and a cloud service to receive messages, and if each of them follows the cryptographic best practice of not sharing keys, then it is impossible to ignore this complexity in some parts of routing design. We call the set of things that Bob controls his sovereign domain (or domain for short). Note that this usage is notably different from the meaning of \"domain\" in DNS and many web contexts. We also use the loose cover term agent to refer to individual devices or pieces of software inside a given domain. The boundary of a domain is an important construct for trust analysis and for routing. We will explore this in greater detail below.","title":"Routing"},{"location":"routing/#routing-requirements","text":"All messaging technologies must address routing in some way. However, DIDComm has unusual requirements: Because of security and privacy goals, DIDComm routing must impose careful limits on how and to what degree intermediate nodes are trusted. Because DIDComm aims to be transport-independent, its routing model must be carefully decoupled from strong assumptions about networking. In particular, DIDComm routing cannot make broad-brush assumptions that: A given route will use only a single transport. Transport mechanisms will provide any security benefits. The identity and connectivity for every hop in a route will be known by any party at the time a message is sent. The route from sender to recipient will be similar in hop identity, hop count, or transport mix to a complementary route from recipient back to sender. All the nodes in a route are ever online at the same time. Because of decentralization and multiple-peer-friendly goals, DIDComm routing cannot orient itself around servers or simple request\u2014response patterns as mandatory components. Because of privacy goals, DIDComm must offer fine distinctions in how repudiation and authentication are handled. These requirements are very demanding. They do NOT necessarily make DIDComm hard to implement. They do NOT prevent DIDComm from using common web infrastructure \u2014 indeed, DIDComm routes quite simply and elegantly over HTTP. However, they DO force the routing model to be described in a very generic, flexible way, and they DO mean that existing routing solutions are an imperfect fit. DIDComm learns as much as it can, and borrows as much as it can, from clever and battle-tested routing work done in other contexts, but it does have some unique twists.","title":"Routing Requirements"},{"location":"routing/#overview","text":"Let's focus on a simple case where A wants to send a message to B , and the route involves one intermediate hop at C . Suppressing a few details, DIDComm routing works like this: A prepares a plaintext message of any type, M[0] , and encrypts it for the recipient, B . This produces M[1] . A prepares another plaintext message of type forward , and adds M[1] to it as an attachment. This new message, M[2] , asks C to to deliver the attached payload to B . A encrypts M[2] for C , producing M[3] . A hands M[3] to C . C decrypts M[3] , producing M[2] . Reading the plaintext, C sees that it's been asked to deliver the encrypted attachment to B . C hands the attachment from M[2] \u2014 which is the encrypted message M[1] \u2014 to B . B decrypts M[1] , reproducing the plaintext M[0] . This is not the simplest possible scenario; DIDComm could be direct from A to C , which would eliminate steps 2-5. Some DIDComm+HTTP interactions are that simple. And it is not the most complex DIDComm routing scenario, either. Much more elaborate routes could be described by introducing additional hops with additional forward messages. However, the above sequence is a good rough model to carry through the discussion that follows.","title":"Overview"},{"location":"routing/#the-forward-message","text":"The forward message created in step 2 in our overview is a DIDComm application-level protocol message. Routing, as described here, is just one of many protocols that can be built atop DIDComm primitives. A and C are \"speaking\" this protocol when they communicate. The routing protocol can use the same features as any other application-level protocol; this includes attachments , message threading , message timing , message tracing , ACKs , problem reports , and so forth. However, before we describe the structure and semantics of the forward message in detail, it's important to understand some additional routing concepts.","title":"The forward message"},{"location":"routing/#two-dimensions","text":"Two dimensions of routing are relevant to DIDComm. Sometimes they are confused or conflated: Network routing deals with how packets flow across a digital landscape. This is the \"routing\" familiar to most technical people, and the one that will inform most assumptions they bring to the routing topic when reading the DIDComm spec for the first time. Cryptographic routing concerns itself with how packaging hides or reveals plaintext to participants in a delivery chain. In other words, it's about the routing of secrets rather than the routing of packets. The overview immediately above collapsed these two dimensions, assuming that a node relaying data is also a node decrypting. This makes for simple explanations, but it's not always a true or helpful assumption. The correspondence between these two routing dimensions can be non-trivial; a route may have ten network hops but only three cryptographic hops, and a single network hop may decrypt twice as it passes data between distinct software entities. However, simple principles explain the dynamics for each situation.","title":"Two Dimensions"},{"location":"routing/#mediators-and-relays","text":"DIDComm routing uses two important constructs to model all varieties of network and cryptographic routing: mediators and relays . A mediator is a participant in routing that must be accounted for by the sender's cryptography. In other words, it is visible in the cryptographic routing dimension. It has its own keys and will deliver messages only after decrypting an outer envelope to reveal a forward request. It must understand DIDComm routing to do this. Many types of mediators may exist, but two important ones should be widely understood, as they commonly manifest in DID Docs: A service that receives messages for many agents at a single endpoint to provide herd privacy (sometimes called an \"agency\") is a mediator . A cloud-based agent that forwards messages to mobile devices is a mediator . In contrast, a relay is an entity that passes along encrypted messages without understanding or decrypting them. It's focused on network routing only. Like mediators, relays can be used to change the transport for a message (e.g., accept an HTTP POST, then turn around and emit an email; accept a Bluetooth transmission, then turn around and emit something in a message queue). But unlike mediators, relays can do this without understanding DIDComm. Load balancers and mix networks like TOR are important types of relay. Let's define mediators and relays by exploring how they manifest in a series of communication scenarios between Alice and Bob.","title":"Mediators and Relays"},{"location":"routing/#scenario-1-direct","text":"Alice and Bob are both employees of a large corporation. They work in the same office, but have never met. The office has a rule that all messages between employees must be encrypted. They use paper messages and physical delivery as the transport. Alice writes a note, encrypts it so only Bob can read it, puts it in an envelope addressed to Bob, and drops the envelope on a desk that she has been told belongs to Bob. This desk is in fact Bob's, and he later picks up the message, decrypts it, and reads it. In this scenario, there is no mediator, and no relay.","title":"Scenario 1: direct"},{"location":"routing/#scenario-2-a-gatekeeper","text":"Imagine that Bob hires an executive assistant, Carl, to filter his mail. Bob won't open any mail unless Carl looks at it and decides that it's worthy of Bob's attention. Alice has to change her behavior. She continues to package a message for Bob, but now she must account for Carl as well. She take the envelope for Bob, and places it inside a new envelope addressed to Carl. Inside the outer envelope, and next to the envelope destined for Bob, Alice writes Carl an encrypted note: \"This inner envelope is for Bob. Please forward.\" Here, Carl is acting as a mediator . He is mostly just passing messages along. But because he is processing a message himself, and because Carl is interposed between Alice and Bob, he affects the behavior of the sender. He is a known entity in the route. You may recognize this as similar to our overview example with A, B, and C. A and B correspond to Alice and Bob; C is Carl, the mediator.","title":"Scenario 2: a gatekeeper"},{"location":"routing/#scenario-3-transparent-indirection","text":"All is the same as the base scenario (Carl has been fired, and is thus out of the picture), except that Bob is working from home when Alice's message lands on his desk. Bob has previously arranged with his friend Darla, who lives near him, to pick up any mail that's on his desk and drop it off at his house at the end of the work day. Darla sees Alice's note and takes it home to Bob. In this scenario, Darla is acting as a relay . Note that Bob arranges for Darla to do this without notifying Alice , and that Alice does not need to adjust her behavior in any way for the relay to work .","title":"Scenario 3: transparent indirection"},{"location":"routing/#scenario-4-more-indirection","text":"Like scenario 3, Darla brings Bob his mail at home. However, Bob isn't at home when his mail arrives. He's had to rush out on an errand, but he's left instructions with his son, Emil, to open any work mail, take a photo of the letter, and text him the photo. Emil intends to do this, but the camera on his phone misfires, so he convinces his sister, Francis, to take the picture on her phone and email it to him. Then he texts the photo to Bob, as arranged. Here, Emil and Francis are also acting as relays. Note that nobody knows about the full route . Alice thinks she's delivering directly to Bob. So does Darla. Bob knows about Darla and Emil, but not about Francis. Note, too, how the transport is changing from physical mail to email to text. To the party immediately upstream (closer to the sender), a relay is indistinguishable from the next party downstream (closer to the recipient). A party anywhere in the chain can insert one or more relays upstream from themselves, as long as those relays are not upstream of another named party (sender or mediator).","title":"Scenario 4: more indirection"},{"location":"routing/#more-scenarios","text":"Mediators and relays can be combined in any order and any amount in variations on our fictional scenario. Bob could employ Carl as a mediator, and Carl could work from home and arrange delivery via George, then have his daughter Hannah run messages back to Bob's desk at work. Carl could hire his own mediator. Darla could arrange for Ivan to substitute for her when she goes on vacation. And so forth.","title":"More Scenarios"},{"location":"routing/#more-traditional-usage","text":"The scenarios used above are somewhat artificial. Our most familiar routing scenarios involve edge agents running on mobile devices and accessible through bluetooth or push notification, and cloud agents that use electronic protocols as their transport. Let's see how relays and mediators apply there.","title":"More Traditional Usage"},{"location":"routing/#scenario-5-direct","text":"Alice's cloud wants to talk to Bob's cloud. Bob's cloud is listening at http://bob.com/api. Alice encrypts a message for Bob and posts it to that URL. In this scenario, we are using a direct transport with neither a mediator nor a relay. This is how Alice and Bob operate in Scenario 1, and it's also equivalent to our Overview minus steps 2-5. When DIDComm involves only two parties, and when HTTP is convenient for both of them, this sort of direct delivery may be used. (Note that if you need n-wise, or if you need a reciprocal return route but Alice's cloud exposes no public API, this delivery scenario can present problems. More on this later.) Virtually the same diagram could be used for a Bluetooth or NFC or sneakernet conversation that happens offline:","title":"Scenario 5: direct"},{"location":"routing/#scenario-6-herd-hosting","text":"Let's tweak Scenario 5 slightly by saying that Bob's agent is one of thousands that are hosted at the same URL. Maybe the URL is now http://agents-r-us.com/inbox. Now if Alice wants to talk to Bob's cloud agent, she has to cope with a mediator. She wraps the encrypted message for Bob's cloud agent inside a forward message that's addressed to and encrypted for the agent of agents-r-us that functions as a gatekeeper. This scenario is one that highlights an external mediator --so-called because the mediator lives outside the sovereign domain of the final recipient.","title":"Scenario 6: herd hosting"},{"location":"routing/#scenario-7-intra-domain-dispatch","text":"Now let's subtract agents-r-us. We're back to Bob's cloud agent listening directly at http://bob.com/agent. However, let's say that Alice has a different goal--now she wants to talk to the edge agent running on Bob's mobile device. This agent doesn't have a permanent IP address, so Bob uses his own cloud agent as a mediator. He tells Alice that his mobile device agent can only be reached via his cloud agent. Once again, this causes Alice to modify her behavior. Again, she wraps her encrypted message. The inner message is enclosed in an outer envelope, and the outer envelope is passed to the mediator. This scenario highlights an internal mediator . Internal and external mediators introduce similar features and similar constraints; the relevant difference is that internal mediators live within the sovereign domain of the recipient, and may thus be worthy of greater trust.","title":"Scenario 7: intra-domain dispatch"},{"location":"routing/#scenario-8-double-mediation","text":"Now let's combine. Bob's cloud agent is hosted at agents-r-us, AND Alice wants to reach Bob's mobile: This is a common pattern with HTTP-based cloud agents plus mobile edge agents, which is the most common deployment pattern we expect for many users of self-sovereign identity. Note that the properties of the agency and the routing agent are not particularly special--they are just an external and an internal mediator, respectively.","title":"Scenario 8: double mediation"},{"location":"routing/#remember-routes-are-one-way-not-duplex","text":"In all of this discussion, note that we are analyzing only a flow from Alice to Bob. How Bob gets a message back to Alice is a completely separate question. Just because Carl, Darla, Emil, Francis, and Agents-R-Us may be involved in how messages flow from Alice to Bob, does not mean they are involved in flow the opposite direction. Note how this breaks the simple assumptions of pure request-response technologies like HTTP, that assume the channel in (request) is also the channel out (response). Duplex request-response can be modeled with DIDComm, but doing so requires support that may not always be available, plus cooperative behavior governed by the ~thread decorator.","title":"Remember Routes are One-Way (not Duplex)"},{"location":"routing/#routing-protocol","text":"Now that we understand mediators and relays, how and why they might be combined in various ways, and how their presence influences delivery semantics, we can describe the actual application-level routing protocol that any DIDComm sender speaks with a destward mediator. See [Routing Protocol] in the spec.","title":"Routing Protocol"},{"location":"scrapbook/","text":"DIDComm v2 scrapbook Here is a chronological list of DIDComm v2 presentations, products, services, efforts, and more. Feel free to submit new links or updates here . DIDComm v2 libs You can find the known DIDComm v2 libs in the Hello World libraries section Chronological scrapbook of DIDComm v2 presentations, usage, efforts, and more Agent Development - Nessus DIDComm v1 and v2 PoC Video Presentation - Sam Curren and Alex Andrei present DIDComm v2 to the Open Wallet Foundation Blog - Daniel Hardman compares/contrasts OIDC, CHAPI, DWN, and DIDComm Live Service - RootsID DIDComm v2 mediator was meant to support mobile DIDComm v2 agents, but is also useful as a test DIDComm v2 interaction/interop service. Video Presentation - Daniel Hardman presents DIDComm v2 to the W3C Agent Development - Veramo has added some DIDComm v2 support and encourages contributions Agent Development - Aries framework javascript (AFJ) DIDComm v1 impl is actively adapting to DIDComm v2 and encourages contributions Agent Development - Aries cloud agent python (ACA-Py) DIDComm v1 impl is actively adapting to DIDComm v2 and encourages contributions","title":"DIDComm v2 scrapbook"},{"location":"scrapbook/#didcomm-v2-scrapbook","text":"Here is a chronological list of DIDComm v2 presentations, products, services, efforts, and more. Feel free to submit new links or updates here .","title":"DIDComm v2 scrapbook"},{"location":"scrapbook/#didcomm-v2-libs","text":"You can find the known DIDComm v2 libs in the Hello World libraries section","title":"DIDComm v2 libs"},{"location":"scrapbook/#chronological-scrapbook-of-didcomm-v2-presentations-usage-efforts-and-more","text":"Agent Development - Nessus DIDComm v1 and v2 PoC Video Presentation - Sam Curren and Alex Andrei present DIDComm v2 to the Open Wallet Foundation Blog - Daniel Hardman compares/contrasts OIDC, CHAPI, DWN, and DIDComm Live Service - RootsID DIDComm v2 mediator was meant to support mobile DIDComm v2 agents, but is also useful as a test DIDComm v2 interaction/interop service. Video Presentation - Daniel Hardman presents DIDComm v2 to the W3C Agent Development - Veramo has added some DIDComm v2 support and encourages contributions Agent Development - Aries framework javascript (AFJ) DIDComm v1 impl is actively adapting to DIDComm v2 and encourages contributions Agent Development - Aries cloud agent python (ACA-Py) DIDComm v1 impl is actively adapting to DIDComm v2 and encourages contributions","title":"Chronological scrapbook of DIDComm v2 presentations, usage, efforts, and more"},{"location":"startConnection/","text":"Starting, using and ending a DIDComm connection This tutorial shows how Alice can invite Bob to start a connection, send and receive encrypted messages using an https transport, and end the relationship. The code relies on DIDComm Python and Peerdid Python libraries from SICPA . The code in the following sections can be executed in a single python file or executed online in this Binder interactive Jupyter notebook Step 1: Imports First, we need to import all required functions, clases and types from didcomm and peerdid libraries. import json import base64 import qrcode import requests import matplotlib.pyplot as plt from typing import Optional, List from didcomm.common.types import DID, VerificationMethodType, VerificationMaterial, VerificationMaterialFormat from didcomm.did_doc.did_doc import DIDDoc, VerificationMethod, DIDCommService from didcomm.did_doc.did_resolver import DIDResolver from didcomm.message import Message, FromPrior from didcomm.secrets.secrets_resolver_demo import SecretsResolverDemo from didcomm.unpack import unpack, UnpackResult from didcomm.common.resolvers import ResolversConfig from didcomm.pack_encrypted import pack_encrypted, PackEncryptedConfig, PackEncryptedResult from peerdid.core.did_doc_types import DIDCommServicePeerDID from didcomm.secrets.secrets_util import generate_x25519_keys_as_jwk_dict, generate_ed25519_keys_as_jwk_dict, jwk_to_secret from peerdid import peer_did from peerdid.did_doc import DIDDocPeerDID from peerdid.types import VerificationMaterialAuthentication, VerificationMethodTypeAuthentication, VerificationMaterialAgreement, VerificationMethodTypeAgreement, VerificationMaterialFormatPeerDID Step 3: Resolvers In this step we add two Resolvers needed by DIDComm and the libraries: Secret resolver: This sample code needs a storage to keep the generated key pair secrets. It will then be referenced by the library as a secrets_resolver . We can instantiate it as follows: secrets_resolver = SecretsResolverDemo() Note that the SecretsResolverDemo simply stores the keys in a text file named secrets.json . As you've just realized, this secret storage is anything but secure. Keep in mind that securing keys is of utmost importance for a self-sovereign identity; never use it in production. DID Resolver: DIDComm only works if your code knows how to resolve DIDs to DID documents. There are various libraries that provide that feature. For example, the Universal Resolver can be used. In this walk-through, we'll provide a simple stub that minimizes dependencies and keeps things as simple as possible. Click here for full example where you'll find the code that do the trick. Step 3: Out of Band Invitation Using our create_peer_did helper function, Alice will create a DID Peer to be shared in the OOB invitation. Since an OOB invitation is unencrypted and may be observed by another party, this DID should not be considered private and must be rotated later for privacy. Alice DID also contains a service part that tells Bob the serviceEndpoint where she accepts messages. In this case Alice provides an https endpoint. For other cases additional Routing may be required. alice_did_oob = await create_peer_did(1, 1, service_endpoint=\"https://www.example.com/alice\") print(\"Alice's OOB DID:\", alice_did_oob) Alice's OOB DID: did:peer:2.Ez6LSh6rmgWhAsvyYRo5mnKTuZtSkMb9keidqDGUygrPD9kgK.Vz6MksqtdXuTar4gjPTMG6tEePL9dFHBc6s7mJxQk8cL98hoj.SeyJpZCI6Im5ldy1pZCIsInQiOiJkbSIsInMiOiJodHRwczovL3d3dy5leGFtcGxlLmNvbS9hbGljZSIsImEiOlsiZGlkY29tbS92MiJdfQ Remember that while creating this DID, our helper function also stores the private keys in the secrets_resolver . In a real implementation, Alice will have her own secure store in her own wallet, and Bob will have a separated secure store in his own wallet. Also, those Peer DIDs can be resolved into DID documents that contain the Authentication , Agreement public keys, and the Service details. With this DID Peer, Alice can create an Out Of Band invitation message as follows: oob_mesage = { \"type\": \"https://didcomm.org/out-of-band/2.0/invitation\", \"id\": \"unique-id-24160d23ed1d\", \"from\": alice_did_oob, \"body\": { \"goal_code\": \"connect\", \"goal\": \"Start relationship\", \"accept\": [ \"didcomm/v2\", \"didcomm/aip2;env=rfc587\" ], } } You can see that the type of the massage was declared as \"https://didcomm.org/out-of-band/2.0/invitation\" and Alice OOB DID was included in the from header. Also, remember that the unique id declared in the message must be used in the parent thread ID pthid in Bob's following response. The message has to be whitespaced removed and encoded using URL Base 64. plaintext_ws_removed = json.dumps(oob_mesage).replace(\" \", \"\") encoded_plaintextjwm = base64.urlsafe_b64encode(plaintext_ws_removed.encode(\"utf-8\")) encoded_text = str(encoded_plaintextjwm, \"utf-8\").replace(\"=\",\"\") Finally, we put the encoded message in a URL that can be emailed to Bob: oob_url = \"https://example.com/path?_oob=\"+encoded_text print(oob_url) https://example.com/path?_oob=eyJ0eXBlIjoiaHR0cHM6Ly9kaWRjb21tLm9yZy9vdXQtb2YtYmFuZC8yLjAvaW52aXRhdGlvbiIsImlkIjoidW5pcXVlLWlkLTI0MTYwZDIzZWQxZCIsImZyb20iOiJkaWQ6cGVlcjoyLkV6NkxTaDZybWdXaEFzdnlZUm81bW5LVHVadFNrTWI5a2VpZHFER1V5Z3JQRDlrZ0suVno2TWtzcXRkWHVUYXI0Z2pQVE1HNnRFZVBMOWRGSEJjNnM3bUp4UWs4Y0w5OGhvai5TZXlKcFpDSTZJbTVsZHkxcFpDSXNJblFpT2lKa2JTSXNJbk1pT2lKb2RIUndjem92TDNkM2R5NWxlR0Z0Y0d4bExtTnZiUzloYkdsalpTSXNJbUVpT2xzaVpHbGtZMjl0YlM5Mk1pSmRmUSIsImJvZHkiOnsiZ29hbF9jb2RlIjoiY29ubmVjdCIsImdvYWwiOiJFc3RhYmxpc2hjb25uZWN0aW9uIiwiYWNjZXB0IjpbImRpZGNvbW0vdjIiLCJkaWRjb21tL2FpcDI7ZW52PXJmYzU4NyJdfX0 Other common option to share the OOB message is by creating a QR code that Bob can scan: image = qrcode.make(oob_url) plt.imshow(image , cmap = 'gray') -- INSERT_QR_CODE_IMAGE_HERE -- Step 4: Receiving the OOB message Once Bob receives the email or scan the QR code, he can easily decod it and read Alice's message: received_msg_encoded = oob_url.split(\"=\")[1] received_msg_decoded = json.loads(str(base64.urlsafe_b64decode(received_msg_encoded + \"==\"), \"utf-8\")) print(received_msg_decoded) {'type': 'https://didcomm.org/out-of-band/2.0/invitation', 'id': 'unique-id-24160d23ed1d', 'from': 'did:peer:2.Ez6LSh6rmgWhAsvyYRo5mnKTuZtSkMb9keidqDGUygrPD9kgK.Vz6MksqtdXuTar4gjPTMG6tEePL9dFHBc6s7mJxQk8cL98hoj.SeyJpZCI6Im5ldy1pZCIsInQiOiJkbSIsInMiOiJodHRwczovL3d3dy5leGFtcGxlLmNvbS9hbGljZSIsImEiOlsiZGlkY29tbS92MiJdfQ', 'body': {'goal_code': 'connect', 'goal': 'Establishconnection', 'accept': ['didcomm/v2', 'didcomm/aip2;env=rfc587']}} After Bob checks the invitation, he is able to prepare a response back. Since Bob has not established a connection with Alice before, he needs to create a DID peer to be used in all communications with Alice. This DID Peer will be dedicated to Alice and only Alice. If Bob needs to comunicate with someone else, he should create a new DID Peer. bob_did = await create_peer_did(1,1, service_endpoint=\"https://www.example.com/bob\") print(\"Bob's DID:\", bob_did) Bob's DID: did:peer:2.Ez6LSfHCNnrXfs6mPio69GbvoL6szGxCXcL3tf8kLDQDYsncm.Vz6MkiDnmWvdnKoFrn7fDfXVykbRmW7MuEyMp1ZcnZu1KvUZL.SeyJpZCI6Im5ldy1pZCIsInQiOiJkbSIsInMiOiJodHRwczovL3d3dy5leGFtcGxlLmNvbS9ib2IiLCJhIjpbImRpZGNvbW0vdjIiXX0 Bob's response will depends on the goal code of the invitation received. Here is a response message as an example: bob_response_message = Message( body = {\"msg\": \"Hi Alice\"}, id = \"unique-id-263e24a422e\", pthid = received_msg_decoded[\"id\"], type = \"my-protocol/1.0\", frm = bob_did, to = [received_msg_decoded[\"from\"]] ) Note that the message includes an id that is mandatory and has to be unique to Bob, but also includes the parent thread ID pthid matching Alice's message id . Also includes a type , also mandatory, that points to the protocol identifier in conformance with the goal of the invitation. The body contains the actual message in a structured way associated by our my-protocol/1.0 . Attributes from and to are optional. Beware that in the code above the property from was replaced by frm due to a conflict of reserved words in Python; the conversion to the correct property ( from ) is handled internally by the library. The final encrypted and packed message can be generated with this code: bob_packed_msg = await pack_encrypted( resolvers_config = ResolversConfig( secrets_resolver = secrets_resolver, did_resolver = DIDResolverPeerDID() ), message = bob_response_message, frm = bob_did, to = alice_did_oob, sign_frm = None, pack_config = PackEncryptedConfig(protect_sender_id=False) ) Step 5: Sending the message to Alice From the received message, Bob can get and resolve Alice's DID into a DID Document. He can use a Universal Resolver or just our helper class as we use in the following lines: alice_did_doc = json.loads(peer_did.resolve_peer_did(received_msg_decoded[\"from\"])) print(alice_did_doc) {'id': 'did:peer:2.Ez6LSh6rmgWhAsvyYRo5mnKTuZtSkMb9keidqDGUygrPD9kgK.Vz6MksqtdXuTar4gjPTMG6tEePL9dFHBc6s7mJxQk8cL98hoj.SeyJpZCI6Im5ldy1pZCIsInQiOiJkbSIsInMiOiJodHRwczovL3d3dy5leGFtcGxlLmNvbS9hbGljZSIsImEiOlsiZGlkY29tbS92MiJdfQ', 'authentication': [{'id': 'did:peer:2.Ez6LSh6rmgWhAsvyYRo5mnKTuZtSkMb9keidqDGUygrPD9kgK.Vz6MksqtdXuTar4gjPTMG6tEePL9dFHBc6s7mJxQk8cL98hoj.SeyJpZCI6Im5ldy1pZCIsInQiOiJkbSIsInMiOiJodHRwczovL3d3dy5leGFtcGxlLmNvbS9hbGljZSIsImEiOlsiZGlkY29tbS92MiJdfQ#6MksqtdXuTar4gjPTMG6tEePL9dFHBc6s7mJxQk8cL98hoj', 'type': 'Ed25519VerificationKey2020', 'controller': 'did:peer:2.Ez6LSh6rmgWhAsvyYRo5mnKTuZtSkMb9keidqDGUygrPD9kgK.Vz6MksqtdXuTar4gjPTMG6tEePL9dFHBc6s7mJxQk8cL98hoj.SeyJpZCI6Im5ldy1pZCIsInQiOiJkbSIsInMiOiJodHRwczovL3d3dy5leGFtcGxlLmNvbS9hbGljZSIsImEiOlsiZGlkY29tbS92MiJdfQ', 'publicKeyMultibase': 'z6MksqtdXuTar4gjPTMG6tEePL9dFHBc6s7mJxQk8cL98hoj'}], 'keyAgreement': [{'id': 'did:peer:2.Ez6LSh6rmgWhAsvyYRo5mnKTuZtSkMb9keidqDGUygrPD9kgK.Vz6MksqtdXuTar4gjPTMG6tEePL9dFHBc6s7mJxQk8cL98hoj.SeyJpZCI6Im5ldy1pZCIsInQiOiJkbSIsInMiOiJodHRwczovL3d3dy5leGFtcGxlLmNvbS9hbGljZSIsImEiOlsiZGlkY29tbS92MiJdfQ#6LSh6rmgWhAsvyYRo5mnKTuZtSkMb9keidqDGUygrPD9kgK', 'type': 'X25519KeyAgreementKey2020', 'controller': 'did:peer:2.Ez6LSh6rmgWhAsvyYRo5mnKTuZtSkMb9keidqDGUygrPD9kgK.Vz6MksqtdXuTar4gjPTMG6tEePL9dFHBc6s7mJxQk8cL98hoj.SeyJpZCI6Im5ldy1pZCIsInQiOiJkbSIsInMiOiJodHRwczovL3d3dy5leGFtcGxlLmNvbS9hbGljZSIsImEiOlsiZGlkY29tbS92MiJdfQ', 'publicKeyMultibase': 'z6LSh6rmgWhAsvyYRo5mnKTuZtSkMb9keidqDGUygrPD9kgK'}], 'service': [{'id': 'did:peer:2.Ez6LSh6rmgWhAsvyYRo5mnKTuZtSkMb9keidqDGUygrPD9kgK.Vz6MksqtdXuTar4gjPTMG6tEePL9dFHBc6s7mJxQk8cL98hoj.SeyJpZCI6Im5ldy1pZCIsInQiOiJkbSIsInMiOiJodHRwczovL3d3dy5leGFtcGxlLmNvbS9hbGljZSIsImEiOlsiZGlkY29tbS92MiJdfQ#didcommmessaging-0', 'type': 'DIDCommMessaging', 'serviceEndpoint': 'https://www.example.com/alice', 'accept': ['didcomm/v2']}]} From the DID Document, Bob can understand how Alice is expecting to receive messages. In this case, he gets Alice's endpoint: alice_endpoint = alice_did_doc[\"service\"][0][\"serviceEndpoint\"] print(alice_endpoint) https://www.example.com/alice Using an https transport Bob can simply POST the message to the endpoint with the message in the body and the media type header set to application/didcomm-encrypted+json . headers = {\"Content-Type\": \"application/didcomm-encrypted+json\"} resp = requests.post(alice_endpoint, headers=headers, data = bob_packed_msg.packed_msg) In a real scenario, you will receive a success http response code in the range of 2XX such as a 202. This case will fail since it's not a real endpoint. Step 5: Alice responding back to Bob with a rotated DID Alice has finally received a response back from Bob at her endpoint. The encrypted message is in the body of the POST request that can be unpacked and decrypted with the following code: bob_unpack_msg = await unpack( resolvers_config=ResolversConfig( secrets_resolver=secrets_resolver, did_resolver=DIDResolverPeerDID() ), packed_msg=bob_packed_msg.packed_msg ) Note that we also passed the resolver config as before. Finally, Alice can see Bob's response message: print(bob_unpack_msg.message.body[\"msg\"]) Hi Alice And also she can get Bob's DID Peer: print(bob_unpack_msg.message.frm) did:peer:2.Ez6LSmYH5Lttu3WFRCJuVyg8RXBD7ncvL5S93ojKUhan2Mhgs.Vz6MkmbHcPTycTGg23jsJK3diDnp4v5tt8hNnvbGWCzs3Trsv.SeyJpZCI6Im5ldy1pZCIsInQiOiJkbSIsInMiOiJodHRwczovL3d3dy5leGFtcGxlLmNvbS9ib2IiLCJhIjpbImRpZGNvbW0vdjIiXX0 and from Bob's DID, she can resolve the DID Document and get Bob's service endpoint: bob_did_doc = json.loads(peer_did.resolve_peer_did(bob_unpack_msg.message.frm)) bob_endpoint = bob_did_doc[\"service\"][0][\"serviceEndpoint\"] print(bob_endpoint) https://www.example.com/bob Now Alice is able to respond back to Bob's. However, in order to keep DID Peers private between them, Alice must replace the DID used in the Out of Band message by a new one. That process is call DID rotation . A DID is rotated by sending a message to Bob including the from_prior header containng a JWT with the new DID in the sub and the prior DID in the iss fields. First, she need to create the new DID Peer: alice_did_new = await create_peer_did(1, 1, service_endpoint=\"https://www.example.com/alice\") print(\"Alice's NEW DID:\", alice_did_new) Alice's NEW DID: did:peer:2.Ez6LSnn1bdY7Zy5WLuXxMQWEpDb2o9L9g8fW9Z2NWdASTAAKd.Vz6MkqFwmMSecezdhHHGMQJPEpjkoSFNVBQRnQG15P1VbgJsN.SeyJpZCI6Im5ldy1pZCIsInQiOiJkbSIsInMiOiJodHRwczovL3d3dy5leGFtcGxlLmNvbS9hbGljZSIsImEiOlsiZGlkY29tbS92MiJdfQ Then, with the help of the library she can easily creat the from_prior header. More details on how to make the JWT can be found in Chapter 5.3 of DIDComm Messaging Specification from_prior = FromPrior(iss=alice_did_oob, sub=alice_did_new) alice_rotate_did_message = Message( body = {\"msg\": \"I'm rotating my peer DID\"}, id = \"unique-id-293e9a922e\", type = \"my-protocol/1.0\", frm = alice_did_new, to = [bob_unpack_msg.message.frm], from_prior = from_prior ) As in previous steps, Alice will encrypt and pack the message, and POST it to Bob's endpoint: alice_packed_msg = await pack_encrypted( resolvers_config = ResolversConfig( secrets_resolver = secrets_resolver, did_resolver = DIDResolverPeerDID() ), message = alice_rotate_did_message, frm = alice_did_new, to = bob_unpack_msg.message.frm, sign_frm = None, pack_config = PackEncryptedConfig(protect_sender_id=False) ) headers = {\"Content-Type\": \"application/didcomm-encrypted+json\"} resp = requests.post(bob_endpoint, headers=headers, data = alice_packed_msg.packed_msg) Bob will receive the message in his endpoint, unpack and decrypt, and get the new Alice's DID. He must store Alice's new DID and use it in subsequent communications. Step 6: What's next --> Protocols Now Alice and Bob have a private way to communicate. This communication channel can be used whenever they need. Normally, messages passed back and forth will follow a protocol that can be understood by both. We won't cover protocols in this tutorial. You can read more about protocols in Chapter 9 of the DIDComm Messaging specification Step 7: Ending a relationship Alice and Bob can use the channel forever. They know how to pass messages and even how to rotate a DID if needed. If for any reason, Alice (or Bob) need to end the relationship, she can simply send a message rotating the DID to nothing. That is achieved by ommiting the sub in the from_prior and sending the message without a from attribute of the message as it's shown below: from_prior_end = FromPrior(iss=alice_did_new, sub=None) alice_end_message = Message( body = {\"msg\": \"I'm finishing this relationship :(\"}, id = \"unique-id-25359a955e\", type = \"my-protocol/1.0\", to = [bob_unpack_msg.message.frm], from_prior = from_prior_end ) alice_end_packed_msg = await pack_encrypted( resolvers_config = ResolversConfig( secrets_resolver = secrets_resolver, did_resolver = DIDResolverPeerDID() ), message = alice_end_message, to = bob_unpack_msg.message.frm, sign_frm = None, pack_config = PackEncryptedConfig(protect_sender_id=False) )","title":"startConnection"},{"location":"startConnection/#starting-using-and-ending-a-didcomm-connection","text":"This tutorial shows how Alice can invite Bob to start a connection, send and receive encrypted messages using an https transport, and end the relationship. The code relies on DIDComm Python and Peerdid Python libraries from SICPA . The code in the following sections can be executed in a single python file or executed online in this Binder interactive Jupyter notebook","title":"Starting, using and ending a DIDComm connection"},{"location":"startConnection/#step-1-imports","text":"First, we need to import all required functions, clases and types from didcomm and peerdid libraries. import json import base64 import qrcode import requests import matplotlib.pyplot as plt from typing import Optional, List from didcomm.common.types import DID, VerificationMethodType, VerificationMaterial, VerificationMaterialFormat from didcomm.did_doc.did_doc import DIDDoc, VerificationMethod, DIDCommService from didcomm.did_doc.did_resolver import DIDResolver from didcomm.message import Message, FromPrior from didcomm.secrets.secrets_resolver_demo import SecretsResolverDemo from didcomm.unpack import unpack, UnpackResult from didcomm.common.resolvers import ResolversConfig from didcomm.pack_encrypted import pack_encrypted, PackEncryptedConfig, PackEncryptedResult from peerdid.core.did_doc_types import DIDCommServicePeerDID from didcomm.secrets.secrets_util import generate_x25519_keys_as_jwk_dict, generate_ed25519_keys_as_jwk_dict, jwk_to_secret from peerdid import peer_did from peerdid.did_doc import DIDDocPeerDID from peerdid.types import VerificationMaterialAuthentication, VerificationMethodTypeAuthentication, VerificationMaterialAgreement, VerificationMethodTypeAgreement, VerificationMaterialFormatPeerDID","title":"Step 1: Imports"},{"location":"startConnection/#step-3-resolvers","text":"In this step we add two Resolvers needed by DIDComm and the libraries: Secret resolver: This sample code needs a storage to keep the generated key pair secrets. It will then be referenced by the library as a secrets_resolver . We can instantiate it as follows: secrets_resolver = SecretsResolverDemo() Note that the SecretsResolverDemo simply stores the keys in a text file named secrets.json . As you've just realized, this secret storage is anything but secure. Keep in mind that securing keys is of utmost importance for a self-sovereign identity; never use it in production. DID Resolver: DIDComm only works if your code knows how to resolve DIDs to DID documents. There are various libraries that provide that feature. For example, the Universal Resolver can be used. In this walk-through, we'll provide a simple stub that minimizes dependencies and keeps things as simple as possible. Click here for full example where you'll find the code that do the trick.","title":"Step 3: Resolvers"},{"location":"startConnection/#step-3-out-of-band-invitation","text":"Using our create_peer_did helper function, Alice will create a DID Peer to be shared in the OOB invitation. Since an OOB invitation is unencrypted and may be observed by another party, this DID should not be considered private and must be rotated later for privacy. Alice DID also contains a service part that tells Bob the serviceEndpoint where she accepts messages. In this case Alice provides an https endpoint. For other cases additional Routing may be required. alice_did_oob = await create_peer_did(1, 1, service_endpoint=\"https://www.example.com/alice\") print(\"Alice's OOB DID:\", alice_did_oob) Alice's OOB DID: did:peer:2.Ez6LSh6rmgWhAsvyYRo5mnKTuZtSkMb9keidqDGUygrPD9kgK.Vz6MksqtdXuTar4gjPTMG6tEePL9dFHBc6s7mJxQk8cL98hoj.SeyJpZCI6Im5ldy1pZCIsInQiOiJkbSIsInMiOiJodHRwczovL3d3dy5leGFtcGxlLmNvbS9hbGljZSIsImEiOlsiZGlkY29tbS92MiJdfQ Remember that while creating this DID, our helper function also stores the private keys in the secrets_resolver . In a real implementation, Alice will have her own secure store in her own wallet, and Bob will have a separated secure store in his own wallet. Also, those Peer DIDs can be resolved into DID documents that contain the Authentication , Agreement public keys, and the Service details. With this DID Peer, Alice can create an Out Of Band invitation message as follows: oob_mesage = { \"type\": \"https://didcomm.org/out-of-band/2.0/invitation\", \"id\": \"unique-id-24160d23ed1d\", \"from\": alice_did_oob, \"body\": { \"goal_code\": \"connect\", \"goal\": \"Start relationship\", \"accept\": [ \"didcomm/v2\", \"didcomm/aip2;env=rfc587\" ], } } You can see that the type of the massage was declared as \"https://didcomm.org/out-of-band/2.0/invitation\" and Alice OOB DID was included in the from header. Also, remember that the unique id declared in the message must be used in the parent thread ID pthid in Bob's following response. The message has to be whitespaced removed and encoded using URL Base 64. plaintext_ws_removed = json.dumps(oob_mesage).replace(\" \", \"\") encoded_plaintextjwm = base64.urlsafe_b64encode(plaintext_ws_removed.encode(\"utf-8\")) encoded_text = str(encoded_plaintextjwm, \"utf-8\").replace(\"=\",\"\") Finally, we put the encoded message in a URL that can be emailed to Bob: oob_url = \"https://example.com/path?_oob=\"+encoded_text print(oob_url) https://example.com/path?_oob=eyJ0eXBlIjoiaHR0cHM6Ly9kaWRjb21tLm9yZy9vdXQtb2YtYmFuZC8yLjAvaW52aXRhdGlvbiIsImlkIjoidW5pcXVlLWlkLTI0MTYwZDIzZWQxZCIsImZyb20iOiJkaWQ6cGVlcjoyLkV6NkxTaDZybWdXaEFzdnlZUm81bW5LVHVadFNrTWI5a2VpZHFER1V5Z3JQRDlrZ0suVno2TWtzcXRkWHVUYXI0Z2pQVE1HNnRFZVBMOWRGSEJjNnM3bUp4UWs4Y0w5OGhvai5TZXlKcFpDSTZJbTVsZHkxcFpDSXNJblFpT2lKa2JTSXNJbk1pT2lKb2RIUndjem92TDNkM2R5NWxlR0Z0Y0d4bExtTnZiUzloYkdsalpTSXNJbUVpT2xzaVpHbGtZMjl0YlM5Mk1pSmRmUSIsImJvZHkiOnsiZ29hbF9jb2RlIjoiY29ubmVjdCIsImdvYWwiOiJFc3RhYmxpc2hjb25uZWN0aW9uIiwiYWNjZXB0IjpbImRpZGNvbW0vdjIiLCJkaWRjb21tL2FpcDI7ZW52PXJmYzU4NyJdfX0 Other common option to share the OOB message is by creating a QR code that Bob can scan: image = qrcode.make(oob_url) plt.imshow(image , cmap = 'gray') -- INSERT_QR_CODE_IMAGE_HERE --","title":"Step 3: Out of Band Invitation"},{"location":"startConnection/#step-4-receiving-the-oob-message","text":"Once Bob receives the email or scan the QR code, he can easily decod it and read Alice's message: received_msg_encoded = oob_url.split(\"=\")[1] received_msg_decoded = json.loads(str(base64.urlsafe_b64decode(received_msg_encoded + \"==\"), \"utf-8\")) print(received_msg_decoded) {'type': 'https://didcomm.org/out-of-band/2.0/invitation', 'id': 'unique-id-24160d23ed1d', 'from': 'did:peer:2.Ez6LSh6rmgWhAsvyYRo5mnKTuZtSkMb9keidqDGUygrPD9kgK.Vz6MksqtdXuTar4gjPTMG6tEePL9dFHBc6s7mJxQk8cL98hoj.SeyJpZCI6Im5ldy1pZCIsInQiOiJkbSIsInMiOiJodHRwczovL3d3dy5leGFtcGxlLmNvbS9hbGljZSIsImEiOlsiZGlkY29tbS92MiJdfQ', 'body': {'goal_code': 'connect', 'goal': 'Establishconnection', 'accept': ['didcomm/v2', 'didcomm/aip2;env=rfc587']}} After Bob checks the invitation, he is able to prepare a response back. Since Bob has not established a connection with Alice before, he needs to create a DID peer to be used in all communications with Alice. This DID Peer will be dedicated to Alice and only Alice. If Bob needs to comunicate with someone else, he should create a new DID Peer. bob_did = await create_peer_did(1,1, service_endpoint=\"https://www.example.com/bob\") print(\"Bob's DID:\", bob_did) Bob's DID: did:peer:2.Ez6LSfHCNnrXfs6mPio69GbvoL6szGxCXcL3tf8kLDQDYsncm.Vz6MkiDnmWvdnKoFrn7fDfXVykbRmW7MuEyMp1ZcnZu1KvUZL.SeyJpZCI6Im5ldy1pZCIsInQiOiJkbSIsInMiOiJodHRwczovL3d3dy5leGFtcGxlLmNvbS9ib2IiLCJhIjpbImRpZGNvbW0vdjIiXX0 Bob's response will depends on the goal code of the invitation received. Here is a response message as an example: bob_response_message = Message( body = {\"msg\": \"Hi Alice\"}, id = \"unique-id-263e24a422e\", pthid = received_msg_decoded[\"id\"], type = \"my-protocol/1.0\", frm = bob_did, to = [received_msg_decoded[\"from\"]] ) Note that the message includes an id that is mandatory and has to be unique to Bob, but also includes the parent thread ID pthid matching Alice's message id . Also includes a type , also mandatory, that points to the protocol identifier in conformance with the goal of the invitation. The body contains the actual message in a structured way associated by our my-protocol/1.0 . Attributes from and to are optional. Beware that in the code above the property from was replaced by frm due to a conflict of reserved words in Python; the conversion to the correct property ( from ) is handled internally by the library. The final encrypted and packed message can be generated with this code: bob_packed_msg = await pack_encrypted( resolvers_config = ResolversConfig( secrets_resolver = secrets_resolver, did_resolver = DIDResolverPeerDID() ), message = bob_response_message, frm = bob_did, to = alice_did_oob, sign_frm = None, pack_config = PackEncryptedConfig(protect_sender_id=False) )","title":"Step 4: Receiving the OOB message"},{"location":"startConnection/#step-5-sending-the-message-to-alice","text":"From the received message, Bob can get and resolve Alice's DID into a DID Document. He can use a Universal Resolver or just our helper class as we use in the following lines: alice_did_doc = json.loads(peer_did.resolve_peer_did(received_msg_decoded[\"from\"])) print(alice_did_doc) {'id': 'did:peer:2.Ez6LSh6rmgWhAsvyYRo5mnKTuZtSkMb9keidqDGUygrPD9kgK.Vz6MksqtdXuTar4gjPTMG6tEePL9dFHBc6s7mJxQk8cL98hoj.SeyJpZCI6Im5ldy1pZCIsInQiOiJkbSIsInMiOiJodHRwczovL3d3dy5leGFtcGxlLmNvbS9hbGljZSIsImEiOlsiZGlkY29tbS92MiJdfQ', 'authentication': [{'id': 'did:peer:2.Ez6LSh6rmgWhAsvyYRo5mnKTuZtSkMb9keidqDGUygrPD9kgK.Vz6MksqtdXuTar4gjPTMG6tEePL9dFHBc6s7mJxQk8cL98hoj.SeyJpZCI6Im5ldy1pZCIsInQiOiJkbSIsInMiOiJodHRwczovL3d3dy5leGFtcGxlLmNvbS9hbGljZSIsImEiOlsiZGlkY29tbS92MiJdfQ#6MksqtdXuTar4gjPTMG6tEePL9dFHBc6s7mJxQk8cL98hoj', 'type': 'Ed25519VerificationKey2020', 'controller': 'did:peer:2.Ez6LSh6rmgWhAsvyYRo5mnKTuZtSkMb9keidqDGUygrPD9kgK.Vz6MksqtdXuTar4gjPTMG6tEePL9dFHBc6s7mJxQk8cL98hoj.SeyJpZCI6Im5ldy1pZCIsInQiOiJkbSIsInMiOiJodHRwczovL3d3dy5leGFtcGxlLmNvbS9hbGljZSIsImEiOlsiZGlkY29tbS92MiJdfQ', 'publicKeyMultibase': 'z6MksqtdXuTar4gjPTMG6tEePL9dFHBc6s7mJxQk8cL98hoj'}], 'keyAgreement': [{'id': 'did:peer:2.Ez6LSh6rmgWhAsvyYRo5mnKTuZtSkMb9keidqDGUygrPD9kgK.Vz6MksqtdXuTar4gjPTMG6tEePL9dFHBc6s7mJxQk8cL98hoj.SeyJpZCI6Im5ldy1pZCIsInQiOiJkbSIsInMiOiJodHRwczovL3d3dy5leGFtcGxlLmNvbS9hbGljZSIsImEiOlsiZGlkY29tbS92MiJdfQ#6LSh6rmgWhAsvyYRo5mnKTuZtSkMb9keidqDGUygrPD9kgK', 'type': 'X25519KeyAgreementKey2020', 'controller': 'did:peer:2.Ez6LSh6rmgWhAsvyYRo5mnKTuZtSkMb9keidqDGUygrPD9kgK.Vz6MksqtdXuTar4gjPTMG6tEePL9dFHBc6s7mJxQk8cL98hoj.SeyJpZCI6Im5ldy1pZCIsInQiOiJkbSIsInMiOiJodHRwczovL3d3dy5leGFtcGxlLmNvbS9hbGljZSIsImEiOlsiZGlkY29tbS92MiJdfQ', 'publicKeyMultibase': 'z6LSh6rmgWhAsvyYRo5mnKTuZtSkMb9keidqDGUygrPD9kgK'}], 'service': [{'id': 'did:peer:2.Ez6LSh6rmgWhAsvyYRo5mnKTuZtSkMb9keidqDGUygrPD9kgK.Vz6MksqtdXuTar4gjPTMG6tEePL9dFHBc6s7mJxQk8cL98hoj.SeyJpZCI6Im5ldy1pZCIsInQiOiJkbSIsInMiOiJodHRwczovL3d3dy5leGFtcGxlLmNvbS9hbGljZSIsImEiOlsiZGlkY29tbS92MiJdfQ#didcommmessaging-0', 'type': 'DIDCommMessaging', 'serviceEndpoint': 'https://www.example.com/alice', 'accept': ['didcomm/v2']}]} From the DID Document, Bob can understand how Alice is expecting to receive messages. In this case, he gets Alice's endpoint: alice_endpoint = alice_did_doc[\"service\"][0][\"serviceEndpoint\"] print(alice_endpoint) https://www.example.com/alice Using an https transport Bob can simply POST the message to the endpoint with the message in the body and the media type header set to application/didcomm-encrypted+json . headers = {\"Content-Type\": \"application/didcomm-encrypted+json\"} resp = requests.post(alice_endpoint, headers=headers, data = bob_packed_msg.packed_msg) In a real scenario, you will receive a success http response code in the range of 2XX such as a 202. This case will fail since it's not a real endpoint.","title":"Step 5: Sending the message to Alice"},{"location":"startConnection/#step-5-alice-responding-back-to-bob-with-a-rotated-did","text":"Alice has finally received a response back from Bob at her endpoint. The encrypted message is in the body of the POST request that can be unpacked and decrypted with the following code: bob_unpack_msg = await unpack( resolvers_config=ResolversConfig( secrets_resolver=secrets_resolver, did_resolver=DIDResolverPeerDID() ), packed_msg=bob_packed_msg.packed_msg ) Note that we also passed the resolver config as before. Finally, Alice can see Bob's response message: print(bob_unpack_msg.message.body[\"msg\"]) Hi Alice And also she can get Bob's DID Peer: print(bob_unpack_msg.message.frm) did:peer:2.Ez6LSmYH5Lttu3WFRCJuVyg8RXBD7ncvL5S93ojKUhan2Mhgs.Vz6MkmbHcPTycTGg23jsJK3diDnp4v5tt8hNnvbGWCzs3Trsv.SeyJpZCI6Im5ldy1pZCIsInQiOiJkbSIsInMiOiJodHRwczovL3d3dy5leGFtcGxlLmNvbS9ib2IiLCJhIjpbImRpZGNvbW0vdjIiXX0 and from Bob's DID, she can resolve the DID Document and get Bob's service endpoint: bob_did_doc = json.loads(peer_did.resolve_peer_did(bob_unpack_msg.message.frm)) bob_endpoint = bob_did_doc[\"service\"][0][\"serviceEndpoint\"] print(bob_endpoint) https://www.example.com/bob Now Alice is able to respond back to Bob's. However, in order to keep DID Peers private between them, Alice must replace the DID used in the Out of Band message by a new one. That process is call DID rotation . A DID is rotated by sending a message to Bob including the from_prior header containng a JWT with the new DID in the sub and the prior DID in the iss fields. First, she need to create the new DID Peer: alice_did_new = await create_peer_did(1, 1, service_endpoint=\"https://www.example.com/alice\") print(\"Alice's NEW DID:\", alice_did_new) Alice's NEW DID: did:peer:2.Ez6LSnn1bdY7Zy5WLuXxMQWEpDb2o9L9g8fW9Z2NWdASTAAKd.Vz6MkqFwmMSecezdhHHGMQJPEpjkoSFNVBQRnQG15P1VbgJsN.SeyJpZCI6Im5ldy1pZCIsInQiOiJkbSIsInMiOiJodHRwczovL3d3dy5leGFtcGxlLmNvbS9hbGljZSIsImEiOlsiZGlkY29tbS92MiJdfQ Then, with the help of the library she can easily creat the from_prior header. More details on how to make the JWT can be found in Chapter 5.3 of DIDComm Messaging Specification from_prior = FromPrior(iss=alice_did_oob, sub=alice_did_new) alice_rotate_did_message = Message( body = {\"msg\": \"I'm rotating my peer DID\"}, id = \"unique-id-293e9a922e\", type = \"my-protocol/1.0\", frm = alice_did_new, to = [bob_unpack_msg.message.frm], from_prior = from_prior ) As in previous steps, Alice will encrypt and pack the message, and POST it to Bob's endpoint: alice_packed_msg = await pack_encrypted( resolvers_config = ResolversConfig( secrets_resolver = secrets_resolver, did_resolver = DIDResolverPeerDID() ), message = alice_rotate_did_message, frm = alice_did_new, to = bob_unpack_msg.message.frm, sign_frm = None, pack_config = PackEncryptedConfig(protect_sender_id=False) ) headers = {\"Content-Type\": \"application/didcomm-encrypted+json\"} resp = requests.post(bob_endpoint, headers=headers, data = alice_packed_msg.packed_msg) Bob will receive the message in his endpoint, unpack and decrypt, and get the new Alice's DID. He must store Alice's new DID and use it in subsequent communications.","title":"Step 5: Alice responding back to Bob with a rotated DID"},{"location":"startConnection/#step-6-whats-next-protocols","text":"Now Alice and Bob have a private way to communicate. This communication channel can be used whenever they need. Normally, messages passed back and forth will follow a protocol that can be understood by both. We won't cover protocols in this tutorial. You can read more about protocols in Chapter 9 of the DIDComm Messaging specification","title":"Step 6: What's next --&gt; Protocols"},{"location":"startConnection/#step-7-ending-a-relationship","text":"Alice and Bob can use the channel forever. They know how to pass messages and even how to rotate a DID if needed. If for any reason, Alice (or Bob) need to end the relationship, she can simply send a message rotating the DID to nothing. That is achieved by ommiting the sub in the from_prior and sending the message without a from attribute of the message as it's shown below: from_prior_end = FromPrior(iss=alice_did_new, sub=None) alice_end_message = Message( body = {\"msg\": \"I'm finishing this relationship :(\"}, id = \"unique-id-25359a955e\", type = \"my-protocol/1.0\", to = [bob_unpack_msg.message.frm], from_prior = from_prior_end ) alice_end_packed_msg = await pack_encrypted( resolvers_config = ResolversConfig( secrets_resolver = secrets_resolver, did_resolver = DIDResolverPeerDID() ), message = alice_end_message, to = bob_unpack_msg.message.frm, sign_frm = None, pack_config = PackEncryptedConfig(protect_sender_id=False) )","title":"Step 7: Ending a relationship"},{"location":"threading/","text":"Threading DIDComm's threading mechanism enables referencing individual messages, the sets of messages that constitute a logically independent interaction (a \"run\" or \"instance\" of a protocol), or even the hierarchies of messages that model nested and recursive workflows. This helps with troubleshooting, debugging, error reporting, resend logic, interactions across more than two parties, and patterns of communication that are more flexible or asynchronous than simple request+response. Some context about the intent and best practices for these features may be helpful: For cybersecurity reasons, the id properties of related messages are intended not to bear any resemblance to one another; id values are expected to be opaque and will likely cause additional issues if they include overloaded semantics that are unique to a particular implementation. This lack of a detectable relationship should be characteristic of id values for messages that stand in sequence to one another, as well as the id properties of forward messages seen by mediators vis-a-vis the id of the innermost plaintext messages they carry. Threads Like threads in email, a thread in DIDComm intends to model a discrete interaction. For protocols that have a beginning and end (e.g., exchanging credentials, playing a game of chess, making a payment), a DIDComm thread maps exactly onto the sequence of messages that embody one such interaction; when a new interaction like this starts, the parties are expected to impute a new thread to the context. However, some DIDComm protocols are not obviously discrete. An example of this might be a human-friendly chat; humans don't necessarily perceive crisp interaction boundaries around any given subset of the messages they trade back and forth. In such cases, a thread might map to a topic, a unit of time, or something else. Applications can structure the thread construct in whatever way makes sense to the implementers, but MUST describe the threading assumptions of the protocol in the protocol's documentation. Parent Threads Parent threads and child threads do not necessarily represent threads of execution or concurrency; they only represent logically separable sequences of messages . A parent thread can trigger multiple child threads, whuch could cascade to multiple levels of nested message threads (for example, issuing a credential triggers payment, which in turn triggers feature discovery). Parent threads and child threads do not have a simple containment or ownership relationship. By definition, a parent is only a trigger \u2014 not necessarily a controller or stakeholder. A parent thread has no guarantees about its lifecycle and could end before or after any of its child threads. Parent and child threads also can interact or share data, but are not required to do so. (How they do so is out of scope in this spec, but see Coprotocols for one way to approach this.) Parent and Child Examples Creating a connection is a classic interaction that lends itself to a parent-child paradigm. Alice and Bob rarely connect just to connect; usually they connect so they can conduct some type of business. In such situations, the connection protocol is a parent thread, and whatever business they then conduct becomes a child. Reporting and resolving errors and warnings is also a good use case for parent and child threads. It is true that problems can be communicated in specialized messages of an individual protocol; some protocols may make this choice. However, problems are often the gateway to deeper troubleshooting or even support tickets, which are complex workflows in their own right. Also, robust mechanisms for logging, analyzing, and reacting to problems may be reusable in many workflows. For this reason, it is recommended to model problem reporting as a child protocol, with an arbitrarily complex thread of messages as child to the parent workflow that triggered them. See Reporting and Handling Problems for more info. Sometimes the parent of a thread is not known, or is so independent of its child as to be irrelevant. If Alice and Bob connected three years ago, each new interaction that they begin doesn't need to declare a pthid that references the original interaction that connected them. Declare a parent relationship for a thread when it is likely to be useful. Message URIs It's generally considered this functionality will be combined with JSPath or JS Pointer so individual elements of messages may also be hyperlinked. For a good idea of the concepts that we'd like to enable with this capability, see Linkable Message Paths .","title":"Threading"},{"location":"threading/#threading","text":"DIDComm's threading mechanism enables referencing individual messages, the sets of messages that constitute a logically independent interaction (a \"run\" or \"instance\" of a protocol), or even the hierarchies of messages that model nested and recursive workflows. This helps with troubleshooting, debugging, error reporting, resend logic, interactions across more than two parties, and patterns of communication that are more flexible or asynchronous than simple request+response. Some context about the intent and best practices for these features may be helpful: For cybersecurity reasons, the id properties of related messages are intended not to bear any resemblance to one another; id values are expected to be opaque and will likely cause additional issues if they include overloaded semantics that are unique to a particular implementation. This lack of a detectable relationship should be characteristic of id values for messages that stand in sequence to one another, as well as the id properties of forward messages seen by mediators vis-a-vis the id of the innermost plaintext messages they carry.","title":"Threading"},{"location":"threading/#threads","text":"Like threads in email, a thread in DIDComm intends to model a discrete interaction. For protocols that have a beginning and end (e.g., exchanging credentials, playing a game of chess, making a payment), a DIDComm thread maps exactly onto the sequence of messages that embody one such interaction; when a new interaction like this starts, the parties are expected to impute a new thread to the context. However, some DIDComm protocols are not obviously discrete. An example of this might be a human-friendly chat; humans don't necessarily perceive crisp interaction boundaries around any given subset of the messages they trade back and forth. In such cases, a thread might map to a topic, a unit of time, or something else. Applications can structure the thread construct in whatever way makes sense to the implementers, but MUST describe the threading assumptions of the protocol in the protocol's documentation.","title":"Threads"},{"location":"threading/#parent-threads","text":"Parent threads and child threads do not necessarily represent threads of execution or concurrency; they only represent logically separable sequences of messages . A parent thread can trigger multiple child threads, whuch could cascade to multiple levels of nested message threads (for example, issuing a credential triggers payment, which in turn triggers feature discovery). Parent threads and child threads do not have a simple containment or ownership relationship. By definition, a parent is only a trigger \u2014 not necessarily a controller or stakeholder. A parent thread has no guarantees about its lifecycle and could end before or after any of its child threads. Parent and child threads also can interact or share data, but are not required to do so. (How they do so is out of scope in this spec, but see Coprotocols for one way to approach this.)","title":"Parent Threads"},{"location":"threading/#parent-and-child-examples","text":"Creating a connection is a classic interaction that lends itself to a parent-child paradigm. Alice and Bob rarely connect just to connect; usually they connect so they can conduct some type of business. In such situations, the connection protocol is a parent thread, and whatever business they then conduct becomes a child. Reporting and resolving errors and warnings is also a good use case for parent and child threads. It is true that problems can be communicated in specialized messages of an individual protocol; some protocols may make this choice. However, problems are often the gateway to deeper troubleshooting or even support tickets, which are complex workflows in their own right. Also, robust mechanisms for logging, analyzing, and reacting to problems may be reusable in many workflows. For this reason, it is recommended to model problem reporting as a child protocol, with an arbitrarily complex thread of messages as child to the parent workflow that triggered them. See Reporting and Handling Problems for more info. Sometimes the parent of a thread is not known, or is so independent of its child as to be irrelevant. If Alice and Bob connected three years ago, each new interaction that they begin doesn't need to declare a pthid that references the original interaction that connected them. Declare a parent relationship for a thread when it is likely to be useful.","title":"Parent and Child Examples"},{"location":"threading/#message-uris","text":"It's generally considered this functionality will be combined with JSPath or JS Pointer so individual elements of messages may also be hyperlinked. For a good idea of the concepts that we'd like to enable with this capability, see Linkable Message Paths .","title":"Message URIs"},{"location":"timeouts/","text":"","title":"Timeouts"},{"location":"vc_tech_vertical/","text":"DIDComm for Verifiable Credentials DIDComm Protocols for Verifiable Credentials allow for the issuance, presentation, and management of Verifiable Credentials. Related Protocols Note that DIDComm allows the use of various protocols between parties. Many applications of Verifiable Credentials are improved with the inclusion of other protocols. Sending a human readable message about credential actions may improve the user experience, for example. Out of Band (OOB) Credentials are often Issued or Presented in association with the scan of a QR Code. The OOB Protocol contains the details of how those QR codes are created, and how they can facilitate an interaction flow directly into the desired protocol. Issue Credential Issue Credential coordinates the issuance of a credential. The protocol supports simple flows and complex flows, and supports any credential type, including those that need some back and forth interaction before credential issuance. Credential issuance may be initiated by either party in the interaction. Present Proof Present Proof coordinates the presention of a Verifiable Credential Proof Presentation. It supports any credential type within the same protocol. Present proof may be initiated by either party in an interaction. Revocation Notification Supports notification to the credential holder that a credential they were previously issued has been revoked. This is initiated from the issuer at some time after credential issuance. Receiving such a notification can improve the user experience for a user in a revocation experience, allowing them to know of the revocation prior to an attempt to present the credential. Additional Protocol Development DIDComm supports the development of additional protocols. Creating a new protocol and promoting it can add useful funcationality into the ecosystem. Support for these protocols can be detected with the Discover Features protocol when communicating with other software.","title":"DIDComm for Verifiable Credentials"},{"location":"vc_tech_vertical/#didcomm-for-verifiable-credentials","text":"DIDComm Protocols for Verifiable Credentials allow for the issuance, presentation, and management of Verifiable Credentials.","title":"DIDComm for Verifiable Credentials"},{"location":"vc_tech_vertical/#related-protocols","text":"Note that DIDComm allows the use of various protocols between parties. Many applications of Verifiable Credentials are improved with the inclusion of other protocols. Sending a human readable message about credential actions may improve the user experience, for example.","title":"Related Protocols"},{"location":"vc_tech_vertical/#out-of-band-oob","text":"Credentials are often Issued or Presented in association with the scan of a QR Code. The OOB Protocol contains the details of how those QR codes are created, and how they can facilitate an interaction flow directly into the desired protocol.","title":"Out of Band (OOB)"},{"location":"vc_tech_vertical/#issue-credential","text":"Issue Credential coordinates the issuance of a credential. The protocol supports simple flows and complex flows, and supports any credential type, including those that need some back and forth interaction before credential issuance. Credential issuance may be initiated by either party in the interaction.","title":"Issue Credential"},{"location":"vc_tech_vertical/#present-proof","text":"Present Proof coordinates the presention of a Verifiable Credential Proof Presentation. It supports any credential type within the same protocol. Present proof may be initiated by either party in an interaction.","title":"Present Proof"},{"location":"vc_tech_vertical/#revocation-notification","text":"Supports notification to the credential holder that a credential they were previously issued has been revoked. This is initiated from the issuer at some time after credential issuance. Receiving such a notification can improve the user experience for a user in a revocation experience, allowing them to know of the revocation prior to an attempt to present the credential.","title":"Revocation Notification"},{"location":"vc_tech_vertical/#additional-protocol-development","text":"DIDComm supports the development of additional protocols. Creating a new protocol and promoting it can add useful funcationality into the ecosystem. Support for these protocols can be detected with the Discover Features protocol when communicating with other software.","title":"Additional Protocol Development"},{"location":"whatsnew/","text":"What's New? The version of DIDComm incubated in the Hyperledger Aries community is referred to as Version 1 (V1). This spec describes the next version, referred to as Version 2 (V2). This section will describe the changes between V1 and V2, useful to members of the Aries community. Summary of Changes Formalization of methods used in V1 JWM based envelope ECDH-1PU standardized form of AuthCrypt Both DID and key in each message Special Handling of Peer DIDs eliminated Message structure split between 'headers' and body. No AnonCrypt encryption method. Practical Changes The list of changes above leads to practical changes in how DIDComm is used. DID Exchange not needed Each message contains both the sender key (used in the encryption layer), and the sender's DID. The exchange of DIDs that occurs via the DID Exchange Protocol used in V1 occurs in each message that is transferred. The important step of rotating DIDs is accomplished via the from_prior header that travels alongside any protocol message. These features make the DID Exchange Protocol redundant. One side effect of the DID Exchange Protocol in V1 was that you confirmed the validity of the DID with a round trip to the other party. Many protocols will provide this assurance via the flow of the protocol prior to the point where round-trip testing is required. When this round-trip is desired prior to the beginning of a protocol, a round trip with another protocol (such as Trust Ping or Feature Discovery) can provide the same assurance. Special Handling of Peer DIDs eliminated DIDComm V1 defined special handling of Peer DIDs, making it very optimized for usage with Peer DIDs. However this made it less obvious how other DID methods could be used with DIDComm. DIDComm V2 eliminated special handling of Peer DIDs, making handling of all DIDs equal from the perspective of the DIDComm spec. This creates a more distinct separation between how DIDs are used (defined by DID Core and specific DID method) and how to securely communicate using DIDs (defined by DIDComm spec). The new to and from attributes inside a DIDComm message allow for query parameters to be included on a DID. Using the query parameters you can exchange additional information without using custom fields. DID methods indicate how query parameters can be used to pass state information. For example, the Peer DID method defines the usage of the initial-state query parameter to pass all information needed to construct a DIDDoc in a single field. Process From Headers prior to Protocol Processing Relationship changes in V1 were handled inside the DID Exchange Protocol. In V2, relationship changes including discovery and rotation are handled in message headers. In V2, messages must evaluate the from and from_prior headers of every message prior to beginning the protocol message processing. No technical difference between Ephemeral Mode and Full Mode Ephemeral mode in V1 was a method of passing messages without first performing an exchange of DIDs. Given that we no longer have a need to perform an exchange of DIDs prior to passing messages of another protocol, we no longer need to designate a mode for ephemeral interactions. Message Level Decorators now represented as Headers The adjusted structure of DIDComm messages now represents message level decorators as message headers. An example includes thid . Return-Route Moved to Extension The return-route mechanism has been moved to an extension due to it's limited application. This mechanism is useful in last-mile message delivery for mobile devices and agents without a public endpoint.","title":"Whatsnew"},{"location":"whatsnew/#whats-new","text":"The version of DIDComm incubated in the Hyperledger Aries community is referred to as Version 1 (V1). This spec describes the next version, referred to as Version 2 (V2). This section will describe the changes between V1 and V2, useful to members of the Aries community.","title":"What's New?"},{"location":"whatsnew/#summary-of-changes","text":"Formalization of methods used in V1 JWM based envelope ECDH-1PU standardized form of AuthCrypt Both DID and key in each message Special Handling of Peer DIDs eliminated Message structure split between 'headers' and body. No AnonCrypt encryption method.","title":"Summary of Changes"},{"location":"whatsnew/#practical-changes","text":"The list of changes above leads to practical changes in how DIDComm is used.","title":"Practical Changes"},{"location":"whatsnew/#did-exchange-not-needed","text":"Each message contains both the sender key (used in the encryption layer), and the sender's DID. The exchange of DIDs that occurs via the DID Exchange Protocol used in V1 occurs in each message that is transferred. The important step of rotating DIDs is accomplished via the from_prior header that travels alongside any protocol message. These features make the DID Exchange Protocol redundant. One side effect of the DID Exchange Protocol in V1 was that you confirmed the validity of the DID with a round trip to the other party. Many protocols will provide this assurance via the flow of the protocol prior to the point where round-trip testing is required. When this round-trip is desired prior to the beginning of a protocol, a round trip with another protocol (such as Trust Ping or Feature Discovery) can provide the same assurance.","title":"DID Exchange not needed"},{"location":"whatsnew/#special-handling-of-peer-dids-eliminated","text":"DIDComm V1 defined special handling of Peer DIDs, making it very optimized for usage with Peer DIDs. However this made it less obvious how other DID methods could be used with DIDComm. DIDComm V2 eliminated special handling of Peer DIDs, making handling of all DIDs equal from the perspective of the DIDComm spec. This creates a more distinct separation between how DIDs are used (defined by DID Core and specific DID method) and how to securely communicate using DIDs (defined by DIDComm spec). The new to and from attributes inside a DIDComm message allow for query parameters to be included on a DID. Using the query parameters you can exchange additional information without using custom fields. DID methods indicate how query parameters can be used to pass state information. For example, the Peer DID method defines the usage of the initial-state query parameter to pass all information needed to construct a DIDDoc in a single field.","title":"Special Handling of Peer DIDs eliminated"},{"location":"whatsnew/#process-from-headers-prior-to-protocol-processing","text":"Relationship changes in V1 were handled inside the DID Exchange Protocol. In V2, relationship changes including discovery and rotation are handled in message headers. In V2, messages must evaluate the from and from_prior headers of every message prior to beginning the protocol message processing.","title":"Process From Headers prior to Protocol Processing"},{"location":"whatsnew/#no-technical-difference-between-ephemeral-mode-and-full-mode","text":"Ephemeral mode in V1 was a method of passing messages without first performing an exchange of DIDs. Given that we no longer have a need to perform an exchange of DIDs prior to passing messages of another protocol, we no longer need to designate a mode for ephemeral interactions.","title":"No technical difference between Ephemeral Mode and Full Mode"},{"location":"whatsnew/#message-level-decorators-now-represented-as-headers","text":"The adjusted structure of DIDComm messages now represents message level decorators as message headers. An example includes thid .","title":"Message Level Decorators now represented as Headers"},{"location":"whatsnew/#return-route-moved-to-extension","text":"The return-route mechanism has been moved to an extension due to it's limited application. This mechanism is useful in last-mile message delivery for mobile devices and agents without a public endpoint.","title":"Return-Route Moved to Extension"},{"location":"why/","text":"Why DIDComm? This guide contains concepts, explanations, and important considerations for those building DIDComm capable systems.","title":"Why DIDComm?"},{"location":"why/#why-didcomm","text":"This guide contains concepts, explanations, and important considerations for those building DIDComm capable systems.","title":"Why DIDComm?"}]}